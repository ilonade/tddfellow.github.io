<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Testing | That TDD Fellow | Tech Blog | Screencasts]]></title>
  <link href="http://www.tddfellow.com/blog/categories/testing/atom.xml" rel="self"/>
  <link href="http://www.tddfellow.com/"/>
  <updated>2016-09-11T22:25:10+02:00</updated>
  <id>http://www.tddfellow.com/</id>
  <author>
    <name><![CDATA[Oleksii Fedorov (waterlink)]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Build Your Own Testing Framework. Part 3]]></title>
    <link href="http://www.tddfellow.com/blog/2016/08/14/build-your-own-testing-framework-part-3/"/>
    <updated>2016-08-14T13:55:17+02:00</updated>
    <id>http://www.tddfellow.com/blog/2016/08/14/build-your-own-testing-framework-part-3</id>
    <content type="html"><![CDATA[<p>Welcome back to the new issue of &ldquo;Build Your Own Testing Framework&rdquo; series! Today we are going to unit-test <code>runTestSuite</code> function of our testing framework. Currently, only its happy path is implicitly tested via every test of the system. Additionally, this function&rsquo;s unhappy paths are, in fact, untestable at the moment.</p>

<p>This article is the third one of the series &ldquo;Build Your Own Testing Framework&rdquo;, so make sure to stick around for next parts! All articles of these series can be found <a href="/blog/categories/build-your-own-testing-framework/">here</a>.</p>

<p>Shall we get started?</p>

<h2>Testing existing code</h2>

<p>Let&rsquo;s take another look at the <code>runTestSuite</code> function:</p>

<pre><code class="javascript">function runTestSuite(testSuiteConstructor) {
    var testSuite = new testSuiteConstructor(assertions);

    for (var testName in testSuite) {
        if (testName.match(/^test/)) {
            testSuite[testName]();
        }
    }
}
</code></pre>

<p>This function currently:</p>

<ol>
<li>Creates a new test suite from the passed in function-constructor.</li>
<li>Finds every method that starts with the string <code>test</code>.</li>
<li>And calls every such method.</li>
</ol>


<h3>Test that it calls at least one test method</h3>

<pre><code class="javascript">var runTestSuite = require("../src/TestingFramework");

runTestSuite(function (t) {
    this.testItCallsOneTestMethod = function () {
        var called = false;

        runTestSuite(function (t) {
            this.testSomeInterestingFunction = function () {
                called = true;
            };
        });

        t.assertTrue(called);
    };
});
</code></pre>

<p>And this test passes. To be sure, that we are actually testing anything, let&rsquo;s make sure that <code>testSomeInterestingFunction</code> is not being called:</p>

<pre><code class="javascript">if (testName.match(/^test/) &amp;&amp;
    testName != "testSomeInterestingFunction") {
//  ^   make sure our method is not called  ^
    testSuite[testName]();
}
</code></pre>

<p>This fails as expected: <code>Error: Expected to be true, but got false</code>. Undoing this mutation causes the test to pass again. This is good, since we have seen this test fail when we expect it to fail. This proves the semantic stability of our test.</p>

<p>So, what will happen if we replace the whole <code>if</code> condition with <code>true</code>?</p>

<pre><code class="javascript">if (true) {
    testSuite[testName]();
}
</code></pre>

<p>As expected, all tests will pass. Seems that we need to add a new test here:</p>

<h3>Test that it does not call non-test methods</h3>

<pre><code class="javascript">this.testItDoesNotCallMethodThatDoesNotStartWithTestPrefix = function () {
    var called = false;

    runTestSuite(function (t) {
        this.someFunction = function () {
            called = true;
        };
    });

    t.assertTrue(!called);
};
</code></pre>

<p>And this fails as expected. This makes our test suite semantically stable against this sort of mutation. Undoing the mutation should make the test suite pass. And it does.</p>

<p>There is another surviving mutant that I can come up with:</p>

<pre><code class="javascript">for (var testName in testSuite) {
    if (testName.match(/^test/)) {
        testSuite[testName]();
    }
    break; // &lt;- surviving mutant
}
</code></pre>

<p>This means, that only first function will only ever run. Since all our tests are currently verifying that only one function is called or not we will need another test to defeat this mutant:</p>

<h3>Test that it calls all provided test methods</h3>

<pre><code class="javascript">this.testItCallsAllTestMethods = function () {
    var calledOne = false;
    var calledTwo = false;
    var calledThree = false;

    runTestSuite(function (t) {
        this.testFunctionOne = function () {
            calledOne = true;
        };

        this.testFunctionTwo = function () {
            calledTwo = true;
        };

        this.testFunctionThree = function () {
            calledThree = true;
        };
    });

    t.assertTrue(calledOne);
    t.assertTrue(calledTwo);
    t.assertTrue(calledThree);
};
</code></pre>

<p>Careful here: <code>testItCallsAllTestMethods</code> has to be the first test in the test suite for it to be ever called with the current mutation. As expected this test fails and undoing the mutation makes it pass.</p>

<p><code>testItCallsAllTestMethods</code> is superior to the <code>testItCallsOneTestMethod</code>, so we can remove the latter.</p>

<p>The amount of duplication in this code does not make me happy. Seems like we are missing the ability to verify if a certain function was called or not. Let&rsquo;s try to extract this abstraction:</p>

<pre><code class="javascript">function spy() {
    function that() {
        that.called = true;
    }

    that.called = false;

    return that;
};
</code></pre>

<p>And then the usage would look like that:</p>

<pre><code class="javascript">this.testItCallsAllTestMethods = function () {
    var spyOne = spy();
    var spyTwo = spy();
    var spyThree = spy();

    runTestSuite(function (t) {
        this.testFunctionOne = spyOne;
        this.testFunctionTwo = spyTwo;
        this.testFunctionThree = spyThree;
    });

    t.assertTrue(spyOne.called);
    t.assertTrue(spyTwo.called);
    t.assertTrue(spyThree.called);
};

this.testItDoesNotCallMethodThatDoesNotStartWithTestPrefix = function () {
    var aSpy = spy();

    runTestSuite(function (t) {
        this.someFunction = aSpy;
    });

    t.assertTrue(!aSpy.called);
};
</code></pre>

<h2>Testing <code>assertions.spy()</code></h2>

<p>It seems, that having <code>t.spy()</code> available for the users of our testing framework might be very useful! Let&rsquo;s test-drive it:</p>

<pre><code class="javascript">// Initially, it should not be called
this.testIsNotCalledInitially = function () {
    t.assertTrue(!t.spy().called);
};

// TypeError: t.spy is not a function

// Implementation in `assertions object`:
spy: function () {
    return {
        called: false
    }
}

// Let's check that it can be called as a function
this.testItCanBeCalledAsFunction = function () {
    t.spy()();
};

// TypeError: t.spy(...) is not a function

// Simplest implementation:
spy: function () {
    return function () {};
}

// Let's check that after being called it has correct `.called` value
this.testIsCalledAfterBeingCalled = function () {
    var aSpy = t.spy();
    aSpy();
    t.assertTrue(aSpy.called);
};

// Error: Expected to be true, but got false

// And final implementation:
spy: function () {
    return function that() {
        that.called = true;
    };
}
</code></pre>

<p>Test <code>testItCanBeCalledAsFunction</code> is inferior to <code>testIsCalledAfterBeingCalled</code>, so we can remove it.</p>

<p>To make the assertion more fluent we might want to have <code>aSpy.assertCalled()</code> and <code>aSpy.assertNotCalled()</code>:</p>

<pre><code class="javascript">// Let's replace our first test's `assertTrue(!...)` with `.assertNotCalled()`
this.testIsNotCalledInitially = function () {
    t.spy().assertNotCalled();
};

// TypeError: t.spy(...).assertNotCalled is not a function

// And the stupid implementation:
spy: function () {
    function that() {
        that.called = true;
    }

    that.assertNotCalled = function () {};

    return that;
}

// This needs some triangulation:
this.testAssertNotCalledFailsWhenWasCalled = function () {
    var aSpy = t.spy();
    aSpy();

    t.assertThrow("Expected not to be called", function () {
        aSpy.assertNotCalled();
    });
};

// Error: Expected to throw an error, but nothing was thrown

// And to make it pass:
that.assertNotCalled = function () {
    assertions.assertTrue(!that.called, "Expected not to be called");
};
</code></pre>

<p>Let&rsquo;s do the same with the other test:</p>

<pre><code class="javascript">// Replace `assertTrue` in the second test with `assertCalled`:
this.testIsCalledAfterBeingCalled = function () {
    var aSpy = t.spy();
    aSpy();
    aSpy.assertCalled();
};

// TypeError: aSpy.assertCalled is not a function

// And the stupid implementation:
that.assertCalled = function () {};

// Let's triangulate it a bit:
this.testAssertCalledFailsWhenWasNotCalled = function () {
    t.assertThrow("Expected to be called", function () {
        t.spy().assertCalled();
    });
};

// Error: Expected to throw an error, but nothing was thrown

// And the implementation:
that.assertCalled = function () {
    assertions.assertTrue(that.called, "Expected to be called");
};
</code></pre>

<p>And the full implementation of <code>spy()</code> function:</p>

<pre><code class="javascript">spy: function () {
    function that() {
        that.called = true;
    }

    that.assertNotCalled = function () {
        assertions.assertTrue(!that.called, "Expected not to be called");
    };

    that.assertCalled = function () {
        assertions.assertTrue(that.called, "Expected to be called");
    };

    return that;
}
</code></pre>

<h2>Bottom Line</h2>

<p>Today we have tested all the existing behavior of the <code>runTestSuite</code> function. That has driven us to implement very simple spies for our testing framework.</p>

<p>We have successfully applied manual Mutational Testing to the existing functionality to derive Semantically Stable tests for it. We did some Triangulation too today. Generally speaking, in TDD Triangulation technique is something that is used on a daily basis, when TDD is practiced properly. Future articles will expand on Triangulation, Mutational Testing, and Semantic Stability in more detail, so stay tuned!</p>

<p>There are only a few problems left, that bother me:</p>

<ul>
<li>We often do <code>t.assertTrue(!condition)</code>, seems that we lack <code>t.assertFalse(condition)</code> assertion.</li>
<li>We often call functions without any assertions to do an implicit assertion, that the call is not throwing any exception. This can be confusing: it is better to make that assertion explicitly - seems like we need <code>t.assertNotThrow</code>.</li>
<li>Seems that it is useful to have <code>NOT</code> version of every assertion. Even though we don&rsquo;t need <code>t.assertNotEqual</code> right now, from my experience with testing it is often very useful.</li>
</ul>


<p>Creating these assertions I will leave as an exercise to the reader. From now on, we will assume they are implemented and we will use them where appropriate. Code is available on GitHub: <a href="https://github.com/waterlink/BuildYourOwnTestingFrameworkPart3">https://github.com/waterlink/BuildYourOwnTestingFrameworkPart3</a></p>

<p>Next time we will add more requirements for our <code>runTestSuite</code> function, such as:</p>

<ul>
<li>Continue running tests after the first failure.</li>
<li>Report successfully passed tests.</li>
<li>Report failures.</li>
<li>Report test run stats (counts of successful and failed tests).</li>
<li>Avoid shared state between tests of the same test suite.</li>
</ul>


<p>Stay tuned!</p>

<h2>Thanks!</h2>

<p>Thank you for reading, my dear reader. If you liked it, please share this article on social networks and follow me on twitter: <a href="https://twitter.com/waterlink000">@waterlink000</a>.</p>

<p>If you have any questions or feedback for me, don&rsquo;t hesitate to reach me out on Twitter: <a href="https://twitter.com/waterlink000">@waterlink000</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Build Your Own Testing Framework. Part 2]]></title>
    <link href="http://www.tddfellow.com/blog/2016/07/23/build-your-own-testing-framework-part-2/"/>
    <updated>2016-07-23T14:52:42+02:00</updated>
    <id>http://www.tddfellow.com/blog/2016/07/23/build-your-own-testing-framework-part-2</id>
    <content type="html"><![CDATA[<p>Today we are going to unit-test existing functionality of our own testing framework, that we have test-driven with <code>FizzBuzzKata</code> in <a href="/blog/2016/07/15/build-your-own-testing-framework/">the previous part</a>.</p>

<p>This needs to be done, since currently only happy paths are implicitly tested via <code>FizzBuzzKata</code> test suite, i.e.: when all the tests pass. The following unhappy paths are not tested at the moment:</p>

<ul>
<li>when <code>assertTrue</code> fails, it throws an error,</li>
<li>when <code>assertEqual</code> fails, it throws an error,</li>
<li>when the test fails, it renders the error and fails the whole test suite run, i.e.: non-zero exit code.</li>
</ul>


<p>This article is the second one of the series &ldquo;Build Your Own Testing Framework&rdquo;, so make sure to stick around for next parts! All articles of these series can be found here: <a href="http://www.tddfellow.com/blog/categories/build-your-own-testing-framework/.">http://www.tddfellow.com/blog/categories/build-your-own-testing-framework/.</a></p>

<p>Shall we get the ball rolling?</p>

<h2>Testing <code>assertTrue(condition, message)</code></h2>

<p>Let&rsquo;s create a test suite for <code>assertTrue</code> with the first test for the case, when <code>assertTrue</code> succeeds:</p>

<pre><code class="javascript">// test/AssertTrueTest.js
var runTestSuite = require("../src/TestingFramework");

runTestSuite(function (t) {
    this.testSuccess = function () {
        t.assertTrue(true);
    };
});
</code></pre>

<p>If we run this test suite, it should not fail:</p>

<pre><code>/usr/local/bin/node AssertTrueTest.js

Process finished with exit code 0
</code></pre>

<p>Let&rsquo;s check if that test actually is testing anything by trying to break the implementation of <code>assertTrue</code>:</p>

<pre><code class="javascript">// src/TestingFramework.js

assertTrue: function (condition, message) {
    if (condition) {    // &lt;- this condition was inverted
        throw new Error(...);
    }
},
</code></pre>

<p>And if we run it, we get the expected error:</p>

<pre><code>/usr/local/bin/node AssertTrueTest.js
/path/to/project/src/TestingFramework.js:4
            throw new Error(message || "Expected to be true, but got false");
            ^

Error: Expected to be true, but got false
    .. stack trace ..

Process finished with exit code 1
</code></pre>

<p>OK, it fails as expected, now we should undo our breaking change in the implementation and run the test suite again and it should pass:</p>

<pre><code class="javascript">// src/TestingFramework.js

assertTrue: function (condition, message) {
    if (!condition) {    // &lt;- the breaking change here have been undone
        throw new Error(...);
    }
},
</code></pre>

<pre><code>/usr/local/bin/node AssertTrueTest.js

Process finished with exit code 0
</code></pre>

<p>Now, let&rsquo;s write a new test for the case, when <code>assertTrue</code> fails:</p>

<pre><code class="javascript">// test/AssertTrueTest.js

this.testFailure = function () {
    try {
        t.assertTrue(false);
    } catch (error) {
        t.assertEqual("Expected to be true, but got false", error.message);
    }
};
</code></pre>

<p>And if we run the test suite, it passes. If I was confident in the previous test, that I know why it didn&rsquo;t fail, here I feel a bit uncomfortable about writing these 5 lines of test code and never seeing them fail. So let&rsquo;s break the code once again!</p>

<pre><code class="javascript">// src/TestingFramework.js

assertTrue: function (condition, message) {
    if (!condition) {
        throw new Error(message || "oops");   // &lt;- we have changed error message here
    }
},
</code></pre>

<p>And if we run tests, we get an expected failure:</p>

<pre><code>/usr/local/bin/node AssertTrueTest.js
/path/to/project/src/TestingFramework.js:4
            throw new Error(message || "oops");
            ^

Error: Expected to equal Expected to be true, but got false, but got: oops
    .. stack trace ..

Process finished with exit code 1
</code></pre>

<p>And if we undo our breaking change in the implementation the test should pass:</p>

<pre><code class="javascript">// src/TestingFramework.js

assertTrue: function (condition, message) {
    if (!condition) {
        throw new Error(message || "Expected to be true, but got false");
        //                         ^ we have restored correct message ^
    }
},
</code></pre>

<pre><code>/usr/local/bin/node AssertTrueTest.js

Process finished with exit code 0
</code></pre>

<p>And the last test for <code>assertTrue</code> to test the custom failure message:</p>

<pre><code class="javascript">// test/AssertTrueTest.js

this.testCustomFailureMessage = function () {
    try {
        t.assertTrue(false, "it is not true!");
    } catch (error) {
        t.assertEqual("it is not true!", error.message);
    }
};
</code></pre>

<p>If we run the test suite, it passes:</p>

<pre><code>/usr/local/bin/node AssertTrueTest.js

Process finished with exit code 0
</code></pre>

<p>Even that I am confident enough, that this <code>try { ... } catch (..) { ... }</code> construction does the right thing, let&rsquo;s be diligent about it and break the implementation of that functionality and see this test fail:</p>

<pre><code class="javascript">// src/TestingFramework.js

assertTrue: function (condition, message) {
    if (!condition) {
        throw new Error("Expected to be true, but got false");
        //              ^ 'message || ' was removed here   ^
    }
},
</code></pre>

<p>If we run the test suite:</p>

<pre><code>/usr/local/bin/node AssertTrueTest.js
/path/to/project/src/TestingFramework.js:4
            throw new Error("Expected to be true, but got false");
            ^

Error: Expected to be true, but got false
    .. stack trace ..

Process finished with exit code 1
</code></pre>

<p>It fails, but this change breaks <code>assertEqual</code> too so that we don&rsquo;t see any meaningful error message now. We can figure out if that is an expected failure or not by inspecting the stack trace:</p>

<pre><code>Error: Expected to be true, but got false
    at Object.assertions.assertTrue (/path/to/project/src/TestingFramework.js:4:19)
    at Object.assertions.assertEqual (/path/to/project/src/TestingFramework.js:9:14)
    at testCustomFailureMessage (/path/to/project/test/AssertTrueTest.js:20:15)
    at runTestSuite (/path/to/project/src/TestingFramework.js:21:32)
    at Object.&lt;anonymous&gt; (/path/to/project/test/AssertTrueTest.js:3:1)
    at Module._compile (module.js:409:26)
    at Object.Module._extensions..js (module.js:416:10)
    at Module.load (module.js:343:32)
    at Function.Module._load (module.js:300:12)
    at Function.Module.runMain (module.js:441:10)
</code></pre>

<p>and precisely this line is the most interesting one:</p>

<pre><code>at testCustomFailureMessage (/path/to/project/test/AssertTrueTest.js:20:15)
</code></pre>

<p>If we open the code at this stack trace frame, we will see:</p>

<pre><code class="javascript">t.assertEqual("it is not true!", error.message);
</code></pre>

<p>Great, this is exactly what we expected. Undoing the breaking change and running the test suite again:</p>

<pre><code class="javascript">// src/TestingFramework.js

assertTrue: function (condition, message) {
    if (!condition) {
        throw new Error(message || "Expected to be true, but got false");
        //              ^ 'message || ' was inserted here again       ^
    }
},
</code></pre>

<pre><code>/usr/local/bin/node AssertTrueTest.js

Process finished with exit code 0
</code></pre>

<p>Interestingly enough, I know how to break the code now and all the tests will pass:</p>

<p>First, let&rsquo;s extract local variable in <code>assertTrue</code>:</p>

<pre><code class="javascript">// src/TestingFramework.js

assertTrue: function (condition, message) {
    var errorMessage = message || "Expected to be true, but got false";

    if (!condition) {
        throw new Error(errorMessage);
    }
},
</code></pre>

<p>And that still passes its tests:</p>

<pre><code>/usr/local/bin/node AssertTrueTest.js

Process finished with exit code 0
</code></pre>

<p>Now let&rsquo;s expand <code>message ||</code> into the proper <code>if</code> statement:</p>

<pre><code class="javascript">var errorMessage = "Expected to be true, but got false";

if (message) {
    errorMessage = message;
}
</code></pre>

<p>And that still passes its tests:</p>

<pre><code>/usr/local/bin/node AssertTrueTest.js

Process finished with exit code 0
</code></pre>

<p>Now, what if I were to replace <code>errorMessage = message;</code> with <code>errorMessage = "it is not true!";</code> inside of the <code>if</code> statement:</p>

<pre><code class="javascript">if (message) {
    errorMessage = "it is not true!";
}
</code></pre>

<p>The test still passes!</p>

<pre><code>/usr/local/bin/node AssertTrueTest.js

Process finished with exit code 0
</code></pre>

<p>This is rather interesting. It seems, that we will have to make sure, that <code>message</code> parameter actually gets passed to <code>new Error(...)</code>. We can do that by applying the Triangulation technique focusing on <code>message</code> parameter:</p>

<pre><code class="javascript">// test/AssertTrueTest.js

this.testCustomFailureMessage_withOtherMessage = function () {
    try {
        t.assertTrue(false, "should be true");
    } catch (error) {
        t.assertEqual("should be true", error.message);
    }
};
</code></pre>

<p>And if we run the test suite, we get our expected failure:</p>

<pre><code>/usr/local/bin/node AssertTrueTest.js
/path/to/project/src/TestingFramework.js:10
            throw new Error(errorMessage);
            ^

Error: it is not true!
    ...
    at testCustomFailureMessage_withOtherMessage (/path/to/project/test/AssertTrueTest.js:28:15)
    ...

Process finished with exit code 1
</code></pre>

<p>And if we look at the stack trace frame, it points us to the correct line of code:</p>

<pre><code class="javascript">t.assertEqual("should be true", error.message);
</code></pre>

<p>And we can now fix the test by fixing the implementation:</p>

<pre><code class="javascript">// src/TestingFramework.js

// inside of `assertTrue` function:
if (message) {
    errorMessage = message;   // &lt;- here we actually have to use 'message' now
}
</code></pre>

<p>And when we run the test suite, it passes:</p>

<pre><code>/usr/local/bin/node AssertTrueTest.js

Process finished with exit code 0
</code></pre>

<p>I think we have all required tests for <code>assertTrue</code> now. This is great! And have you spotted the duplication already?</p>

<h2>Refactoring <code>AssertTrueTest</code></h2>

<p>The duplication that is present here is our <code>try { ... } catch (..) { ... }</code> construct. Let&rsquo;s make it a completely duplicate code by extracting couple of local variables:</p>

<pre><code class="javascript">// first, let's extract the Action Under the Test variable:
var action = function () { t.assertTrue(false); };

try {
    action();
} catch (error) {
    t.assertEqual("Expected to be true, but got false", error.message);
}

// next, let's extract the Expected Error Message:
var expectedMessage = "Expected to be true, but got false";

try {
    action();
} catch (error) {
    t.assertEqual(expectedMessage, error.message);
}
</code></pre>

<p>If we apply the same refactoring for all tests in the <code>AssertTrueTest</code> suite, we will see the duplication:</p>

<pre><code class="javascript">try {
    action();
} catch (error) {
    t.assertEqual(expectedMessage, error.message);
}
</code></pre>

<p>Let&rsquo;s give that operation a name and extract is as a function: <code>assertThrow(expectedMessage, action)</code>:</p>

<pre><code class="javascript">function assertThrow(expectedMessage, action) {
    try {
        action();
    } catch (error) {
        t.assertEqual(expectedMessage, error.message);
    }
}
</code></pre>

<p>Use this function in all tests and inline all the extracted local variables:</p>

<pre><code class="javascript">this.testFailure = function () {
    assertThrow("Expected to be true, but got false", function () {
        t.assertTrue(false);
    });
};

this.testCustomFailureMessage = function () {
    assertThrow("it is not true!", function () {
        t.assertTrue(false, "it is not true!");
    });
};

this.testCustomFailureMessage_withOtherMessage = function () {
    assertThrow("should be true", function () {
        t.assertTrue(false, "should be true");
    });
};
</code></pre>

<p>Function <code>assertThrow</code> seems to be useful for any test, not just <code>AssertTrueTest</code> suite. Let&rsquo;s move it to the <code>assertions</code> object. We will be doing that by using Parallel Change technique:</p>

<ol>
<li>Create new functionality first;</li>
<li>Step by step migrate all calls to use new functionality instead of old one;</li>
<li>Once old functionality is not used, remove it.</li>
</ol>


<p>The advantage of that method is that it consists of very small steps, that can be executed with confidence and each such small step never leaves the user in a red state (failing tests or compile/parsing errors).</p>

<p>Let&rsquo;s see how this one can be applied here:</p>

<p><code>1. Create new functionality first</code> - we can do it by copying the <code>assertThrow</code> function to <code>assertions</code> object:</p>

<pre><code class="javascript">// src/TestingFramework.js

var assertions = {
    // ...
    assertThrow: function (expectedMessage, action) {
        try {
            action();
        } catch (error) {
            // `t` needs to be changed to `this` here
            this.assertEqual(expectedMessage, error.message);
        }
    }
};
</code></pre>

<p>The tests should still pass:</p>

<pre><code>/usr/local/bin/node AssertTrueTest.js

Process finished with exit code 0
</code></pre>

<p><code>2. Step by step migrate all calls to use new functionality instead of old one</code> - we do it by calling <code>assertThrow</code> on <code>t</code> (our assertions object) in the test suite. Since we still haven&rsquo;t removed the old <code>assertThrow</code> function, we can do that one function call at the time and the tests will always be green:</p>

<pre><code class="javascript">this.testFailure = function () {
    t.assertThrow("Expected to be true, but got false", function () {
// ^ 't.' added here ^
        t.assertTrue(false);
    });
};

// run tests and they still pass.

this.testCustomFailureMessage = function () {
    t.assertThrow("it is not true!", function () {
// ^ 't.' added here ^
        t.assertTrue(false, "it is not true!");
    });
};

// run tests and they still pass.

this.testCustomFailureMessage_withOtherMessage = function () {
    t.assertThrow("should be true", function () {
// ^ 't.' added here ^
        t.assertTrue(false, "should be true");
    });
};
</code></pre>

<p><code>3. Once old functionality is not used, remove it.</code> - now we can remove our <code>assertThrow</code> function defined inside of the <code>AssertTrueTest</code> suite and run tests:</p>

<pre><code>/usr/local/bin/node AssertTrueTest.js

Process finished with exit code 0
</code></pre>

<p>And they pass. Let&rsquo;s see the complete <code>AssertTrueTest</code> suite again:</p>

<pre><code class="javascript">// test/AssertTrueTest.js
var runTestSuite = require("../src/TestingFramework");

runTestSuite(function (t) {
    this.testSuccess = function () {
        t.assertTrue(true);
    };

    this.testFailure = function () {
        t.assertThrow("Expected to be true, but got false", function () {
            t.assertTrue(false);
        });
    };

    this.testCustomFailureMessage = function () {
        t.assertThrow("it is not true!", function () {
            t.assertTrue(false, "it is not true!");
        });
    };

    this.testCustomFailureMessage_withOtherMessage = function () {
        t.assertThrow("should be true", function () {
            t.assertTrue(false, "should be true");
        });
    };
});
</code></pre>

<p>The only problem here is that we are relying on the untested <code>assertThrow</code> assertion here. Let&rsquo;s unit-test it.</p>

<h2>Testing <code>assertThrow(expectedMessage, action)</code></h2>

<p>Let&rsquo;s create a new test suite with first test when <code>assertThrow</code> succeeds:</p>

<pre><code class="javascript">// test/AssertThrowTest.js
var runTestSuite = require("../src/TestingFramework");

runTestSuite(function (t) {
    this.testSuccess = function () {
        assertThrow("an error message", function () {
            throw new Error("an error message");
        });
    };
});
</code></pre>

<p>And the test should pass:</p>

<pre><code>/usr/local/bin/node AssertThrowTest.js

Process finished with exit code 0
</code></pre>

<p>The code can be broken without test failure by not using <code>expectedMessage</code> parameter:</p>

<pre><code class="javascript">// src/TestingFramework.js

assertThrow: function (expectedMessage, action) {
    try {
        action();
    } catch (error) {
        this.assertEqual("an error message", error.message);
        // ^ here 'expectedMessage' was changed to constant ^
    }
}
</code></pre>

<p>Let&rsquo;s triangulate the code to make sure <code>expectedMessage</code> is used correctly by adding a new test:</p>

<pre><code class="javascript">// test/AssertThrowTest.js

this.testSuccess_withDifferentExpectedMessage = function () {
    t.assertThrow("a different error message", function () {
        throw new Error("a different error message");
    });
};
</code></pre>

<p>And that test fails as expected:</p>

<pre><code>/usr/local/bin/node AssertThrowTest.js
/path/to/project/src/TestingFramework.js:10
            throw new Error(errorMessage);
            ^

Error: Expected to equal an error message, but got: a different error message

Process finished with exit code 1
</code></pre>

<p>Undoing the breaking change (Mutation) will make the test pass:</p>

<pre><code>/usr/local/bin/node AssertThrowTest.js

Process finished with exit code 0
</code></pre>

<p>Next test is to make sure, that <code>assertThrow</code> is actually comparing actual and expected error messages correctly:</p>

<pre><code class="javascript">// test/AssertThrowTest.js

this.testFailure = function () {
    t.assertThrow("Expected to equal an error message, but got: a different error message", function () {
        t.assertThrow("an error message", function () {
            throw new Error("a different error message");
        });
    });
};
</code></pre>

<p>And it passes. The last test, that <code>assertThrow</code> needs is the case, when <code>action()</code> is not throwing any error. In that case <code>assertThrow</code> should fail:</p>

<pre><code class="javascript">// test/AssertThrowTest.js

this.testFailure_whenActionDoesNotThrow = function () {
    t.assertThrow("Expected to throw an error, but nothing was thrown", function () {
        t.assertThrow("an error message", function () {
            // does nothing
        });
    });
};
</code></pre>

<p>Oh, and that test is passing! We clearly don&rsquo;t have that functionality yet. We have to add another test without usage of outer <code>t.assertThrow</code> to make sure that we get a test failure:</p>

<pre><code class="javascript">this.testThrows_whenActionDoesNotThrow = function () {
    var hasThrown = false;

    try {
        t.assertThrow("an error message", function () {
            // does nothing
        });
    } catch (error) {
        hasThrown = true;
    }

    t.assertTrue(hasThrown, "it should have thrown");
};
</code></pre>

<p>And if we run our tests we get the expected failure:</p>

<pre><code>/usr/local/bin/node AssertThrowTest.js
/path/to/project/src/TestingFramework.js:10
            throw new Error(errorMessage);
            ^

Error: it should have thrown

Process finished with exit code 1
</code></pre>

<p>We can fix that by verifying, that <code>catch</code> block is executed in the <code>assertThrow</code> function:</p>

<pre><code class="javascript">// src/TestingFramework.js

assertThrow: function (expectedMessage, action) {
    var hasThrown = false;  // &lt;- we initialize hasThrown here

    try {
        action();
    } catch (error) {
        hasThrown = true;   // &lt;- and we set it to true in the catch block
        this.assertEqual(expectedMessage, error.message);
    }

    this.assertTrue(hasThrown);  // &lt;- and we check that it is true
}
</code></pre>

<p>And now if we run the test suite, the original test that we were trying to write fails as expected:</p>

<pre><code>/usr/local/bin/node AssertThrowTest.js
/path/to/project/src/TestingFramework.js:10
            throw new Error(errorMessage);
            ^

Error: Expected to equal Expected to throw an error, but nothing was thrown, but got: Expected to be true, but got false

Process finished with exit code 1
</code></pre>

<p>Now we need to fix the custom message provided to <code>assertTrue</code> call inside of <code>assertThrow</code>:</p>

<pre><code class="javascript">// src/TestingFramework.js

// inside of assertThrow:
this.assertTrue(hasThrown, "Expected to throw an error, but nothing was thrown");
</code></pre>

<p>And the test pass:</p>

<pre><code>/usr/local/bin/node AssertThrowTest.js

Process finished with exit code 0
</code></pre>

<p>Great, I think we are done with testing the <code>assertThrow</code> function. Let&rsquo;s see the whole <code>AssertThrowTest</code> suite:</p>

<pre><code class="javascript">// test/AssertThrowTest.js
var runTestSuite = require("../src/TestingFramework");

runTestSuite(function (t) {
    this.testSuccess = function () {
        t.assertThrow("an error message", function () {
            throw new Error("an error message");
        });
    };

    this.testSuccess_withDifferentExpectedMessage = function () {
        t.assertThrow("a different error message", function () {
            throw new Error("a different error message");
        });
    };

    this.testFailure = function () {
        t.assertThrow("Expected to equal an error message, but got: a different error message", function () {
            t.assertThrow("an error message", function () {
                throw new Error("a different error message");
            });
        });
    };

    this.testFailure_whenActionDoesNotThrow = function () {
        t.assertThrow("Expected to throw an error, but nothing was thrown", function () {
            t.assertThrow("an error message", function () {
                // does nothing
            });
        });
    };

    this.testThrows_whenActionDoesNotThrow = function () {
        var hasThrown = false;

        try {
            t.assertThrow("an error message", function () {
                // does nothing
            });
        } catch (error) {
            hasThrown = true;
        }

        t.assertTrue(hasThrown, "it should have thrown");
    };
});
</code></pre>

<p>Last one for today is <code>assertEqual</code>:</p>

<h2>Testing <code>assertEqual(expected, actual)</code></h2>

<p>Let&rsquo;s create a test suite with the first test, when <code>assertEqual</code> succeeds:</p>

<pre><code class="javascript">// test/AssertEqualTest.js
var runTestSuite = require("../src/TestingFramework");

runTestSuite(function (t) {
    this.testSuccess = function () {
        t.assertEqual(42, 42);
    };
});
</code></pre>

<p>This test passes, and it can be broken without test failure by always comparing to <code>42</code>:</p>

<pre><code class="javascript">// src/TestingFramework.js

assertEqual: function (expected, actual) {
    this.assertTrue(
        42 == actual,   // &lt;- here 'expected' is replaced with constant
        "Expected to equal " + expected + ", but got: " + actual
    );
},
</code></pre>

<p>Triangulation to fix that:</p>

<pre><code class="javascript">// test
this.testSuccess_whenExpectedIsDifferent = function () {
    t.assertEqual(29, 29);
};

// Error: Expected to equal 29, but got: 29

// fix implementation:
expected == actual,   // &lt;- here 'expected' is restored

// and the test passes
</code></pre>

<p>Next mutation that does not break any tests looks this way:</p>

<pre><code class="javascript">// src/TestingFramework.js

assertEqual: function (expected, actual) {
    this.assertTrue(
        expected == actual,
        // "Expected to equal " + expected + ", but got: " + actual
        "oops"    // &lt;- replace error message
    );
},
</code></pre>

<p>Let&rsquo;s add the test to protect from this kind of mutation:</p>

<pre><code class="javascript">this.testFailure = function () {
    t.assertThrow("Expected to equal 42, but got: 29", function () {
        t.assertEqual(42, 29);
    });
};
</code></pre>

<p>This fails with <code>Error: oops</code>, because <code>assertThrow</code> uses <code>assertEqual</code>. Stack trace shows, that the failure is happening here:</p>

<pre><code class="javascript">// src/TestingFramework.js in assertThrow
this.assertEqual(expectedMessage, error.message);
</code></pre>

<p>So that is the expected failure. We can fix it by always providing the message <code>"Expected to equal 42, but got: 29"</code>:</p>

<pre><code class="javascript">// src/TestingFramework.js in assertions
assertEqual: function (expected, actual) {
    this.assertTrue(
        expected == actual,
        "Expected to equal 42, but got: 29"
    // ^ here the exact constant is used ^
    );
},
</code></pre>

<p>This needs some more triangulation:</p>

<pre><code class="javascript">this.testFailure_withDifferentExpectedAndActual = function () {
    t.assertThrow("Expected to equal 94, but got: 1027", function () {
        t.assertEqual(94, 1027);
    });
};

// Error: Expected to equal 42, but got: 29

// fix:
this.assertTrue(
    expected == actual,
    "Expected to equal " + expected + ", but got: " + actual
);
</code></pre>

<p>I think we are done now with testing the <code>assertEqual</code> function. The <code>AssertEqualTest</code> suite is looking like that now:</p>

<pre><code class="javascript">// test/AssertEqualTest.js
var runTestSuite = require("../src/TestingFramework");

runTestSuite(function (t) {
    this.testSuccess = function () {
        t.assertEqual(42, 42);
    };

    this.testSuccess_whenExpectedIsDifferent = function () {
        t.assertEqual(29, 29);
    };

    this.testFailure = function () {
        t.assertThrow("Expected to equal 42, but got: 29", function () {
            t.assertEqual(42, 29);
        });
    };

    this.testFailure_withDifferentExpectedAndActual = function () {
        t.assertThrow("Expected to equal 94, but got: 1027", function () {
            t.assertEqual(94, 1027);
        });
    };
});
</code></pre>

<h2>Final <code>assertions</code> object after all the testing</h2>

<pre><code class="javascript">// src/TestingFramework.js
var assertions = {
    assertTrue: function (condition, message) {
        var errorMessage = "Expected to be true, but got false";

        if (message) {
            errorMessage = message;
        }

        if (!condition) {
            throw new Error(errorMessage);
        }
    },

    assertEqual: function (expected, actual) {
        this.assertTrue(
            expected == actual,
            "Expected to equal " + expected + ", but got: " + actual
        );
    },

    assertThrow: function (expectedMessage, action) {
        var hasThrown = false;

        try {
            action();
        } catch (error) {
            hasThrown = true;
            this.assertEqual(expectedMessage, error.message);
        }

        this.assertTrue(
            hasThrown,
            "Expected to throw an error, but nothing was thrown"
        );
    }
};
</code></pre>

<h2>Bottom Line</h2>

<p>Congratulations! We have completely unit-tested our assertions <code>assertTrue</code> and <code>assertEqual</code>. This resulted in natural emergence of the new assertion - <code>assertThrow</code>. We have unit-tested it too!</p>

<p>Additionally, we have practiced usage of Mutational Testing and Triangulation Technique to detect missing test cases and derive them from the code. Also, we have slightly touched the Parallel Change refactoring technique - we will see more of that in the future in these series.</p>

<p>The code is available on Github: <a href="https://github.com/waterlink/BuildYourOwnTestingFrameworkPart2">https://github.com/waterlink/BuildYourOwnTestingFrameworkPart2</a></p>

<p>Now that we have unit-tested some basic assertions, we should unit-test our testing framework test runner: <code>runTestSuite</code> function. This will be covered in next series of &ldquo;Build Your Own Testing Framework&rdquo;. Stay tuned!</p>

<h2>Thanks!</h2>

<p>Thank you for reading, my dear reader. If you liked it, please share this article on social networks and follow me on twitter: <a href="https://twitter.com/waterlink000">@waterlink000</a>.</p>

<p>If you have any questions or feedback for me, don&rsquo;t hesitate to reach me out on Twitter: <a href="https://twitter.com/waterlink000">@waterlink000</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Build Your Own Testing Framework]]></title>
    <link href="http://www.tddfellow.com/blog/2016/07/15/build-your-own-testing-framework/"/>
    <updated>2016-07-15T08:00:06+02:00</updated>
    <id>http://www.tddfellow.com/blog/2016/07/15/build-your-own-testing-framework</id>
    <content type="html"><![CDATA[<p>Today we are going to test-drive the testing framework without any external testing framework.
This will be done through test-driving a simple kata (FizzBuzzKata). For example:</p>

<ul>
<li>every time we expect a test to fail and it doesn&rsquo;t, this is a failing test for our testing framework, that we will be fixing,</li>
<li>every time we expect a test to pass and it doesn&rsquo;t, this is another failing test for our testing framework, that we will be fixing.</li>
</ul>


<p>For practical reasons, today we are going to use concrete programming language instead of pseudo-code - javascript. Except for small details, that we will point out, the techniques shown here are language-agnostic.</p>

<p>This article is only first one of the series &ldquo;Build Your Own Testing Framework&rdquo;, so make sure to stick around for next parts! All articles of these series can be found here: <a href="http://www.tddfellow.com/blog/categories/build-your-own-testing-framework/.">http://www.tddfellow.com/blog/categories/build-your-own-testing-framework/.</a></p>

<p>Shall we begin?</p>

<h2>FizzBuzzKata</h2>

<p>Given the number,</p>

<ul>
<li>return <code>Fizz</code> when the number is divisible by 3,</li>
<li>return <code>Buzz</code> when the number is divisible by 5,</li>
<li>return <code>FizzBuzz</code> when the number is divisible by 3 and 5,</li>
<li>return string representation of number otherwise.</li>
</ul>


<h2>Writing your first test</h2>

<p>How do we write our first test, when we don&rsquo;t have a testing framework and we want to create one? - It seems, that we have to design how the test should like in our brand new testing framework.</p>

<p>I personally, would go with the xUnit-like design, since it is relatively simple. Given this, we might write our first test and it will look something like that:</p>

<pre><code class="javascript">// test/FizzBuzzKataTest.js

function FizzBuzzKataTest() {
    this.testNormalNumberIsReturned = function() {
        this.assertTrue("1" === fizzBuzz(1));
    };
}
</code></pre>

<p>This test should fail, because function <code>fizzBuzz</code> is not defined, but it doesn&rsquo;t fail, since function <code>testNormalNumberIsReturned</code> is never called. In fact, the object with <code>FizzBuzzKataTest</code> is never being created.</p>

<p>Easiest way to solve that:</p>

<pre><code class="javascript">// test/FizzBuzzKataTest.js

function FizzBuzzKataTest() { ... }

var test = new FizzBuzzKataTest();
test.testNormalNumberIsReturned();
</code></pre>

<p>If we run this code with <code>node</code>:</p>

<pre><code class="bash">node test/FizzBuzzKataTest.js
</code></pre>

<p>We will get the expected error:</p>

<pre><code>/path/to/project/test/FizzBuzzKataTest.js:3
        this.assertTrue("1" === fizzBuzz(1));
                               ^

ReferenceError: fizzBuzz is not defined
</code></pre>

<p>So, let&rsquo;s define this function:</p>

<pre><code class="javascript">// test/FizzBuzzKataTest.js

function FizzBuzzKataTest() { ... }

function fizzBuzz() {}
</code></pre>

<p>If we run our test again, we will get the following error:</p>

<pre><code>/path/to/project/test/FizzBuzzKataTest.js:3
        this.assertTrue("1" === fizzBuzz(1));
             ^

TypeError: this.assertTrue is not a function
</code></pre>

<p>Clearly, to fix it we need to define <code>assertTrue</code> on <code>FizzBuzzKataTest</code> object. Obviously, we do not want our user to define all their assertion for every test suite. This means, that we want to define it on <code>FizzBuzzKataTest</code> object outside of the definition of <code>FizzBuzzKataTest</code>.</p>

<p>There are two ways to go about it:</p>

<ul>
<li>inheritance: make <code>FizzBuzzKataTest</code> inherit from some other object function <code>assertTrue</code>, or</li>
<li>composition: make <code>FizzBuzzKataTest</code> accept a special object with function <code>assertTrue</code> defined on it.</li>
</ul>


<p>I would like to go with composition method since it gives us more flexibility in the long run:</p>

<pre><code class="javascript">function FizzBuzzKataTest(t) { ... }
</code></pre>

<p>and the usage of <code>assertTrue</code> has to change appropriately:</p>

<pre><code class="javascript">    t.assertTrue("1" === fizzBuzz(1));
</code></pre>

<p>and <code>t</code> has to be created and passed in correctly:</p>

<pre><code class="javascript">function FizzBuzzKataTest(t) { ... }

function fizzBuzz(number) {}

var assertions = {
    assertTrue: function(condition) {}
};

var test = new FizzBuzzKataTest(assertions);
</code></pre>

<p>If we run the test suite again, we will not get any failure anymore. But we were expecting <code>assertTrue</code> to fail, so let&rsquo;s make it fail:</p>

<pre><code class="javascript">    assertTrue: function(condition) {
        throw new Error("Expected to be true, but was false");
    }
</code></pre>

<p>When we run the test suite, we get:</p>

<pre><code>/path/to/project/test/FizzBuzzKataTest.js:11
        throw new Error("Expected to be true, but got false");
        ^

Error: Expected to be true, but got false
</code></pre>

<p>Now, let&rsquo;s customize the error message a bit:</p>

<pre><code class="javascript">    this.testNormalNumberIsReturned = function() {
        t.assertTrue("1" === fizzBuzz(1), "Expected to equal " + "1" + ", but got: " + fizzBuzz(1));
    }

// ...

    assertTrue: function(condition, message) {
        throw new Error(message || "Expected to be true, but got false");
    }
</code></pre>

<p>When running this, we are getting the expected error:</p>

<pre><code>/path/to/project/test/FizzBuzzKataTest.js:11
        throw new Error(message || "Expected to be true, but got false");
        ^

Error: Expected to equal 1, but got: undefined
</code></pre>

<p>This looks better now. Let&rsquo;s fix the error now by implementing the simplest thing that could work:</p>

<pre><code class="javascript">function fizzBuzz(number) {
    return "1";
}
</code></pre>

<p>And as we run our test suite we get:</p>

<pre><code>/path/to/project/test/FizzBuzzKataTest.js:13
        throw new Error(message || "Expected to be true, but got false");
        ^

Error: Expected to equal 1, but got: 1
</code></pre>

<p>Oh, it should have passed the test. I know why it didn&rsquo;t: we throw this error unconditionally, let&rsquo;s add an appropriate <code>if</code> statement to <code>assertTrue</code> function:</p>

<pre><code class="javascript">    assertTrue: function(condition, message) {
        if (!condition) {
            throw new Error(...);
        }
    }
</code></pre>

<p>If we run this code, it does not fail. That was our first green state - it took as awhile to get here. The reason for this is that we are not only test-driving <code>FizzBuzzKata</code>, additionally, we are writing a feature test for a non-existing testing framework. Now that we are green, we should think about refactoring, i.e.: making the structure of our code right.</p>

<p>Obviously, we should move our testing framework code outside of the test suite file. Probably, somewhere in <code>src/TestingFramework.js</code>. For that, we need to first parametrize <code>FizzBuzzKataTest</code> and extract the function to run the test suite.</p>

<p>Parametrize:</p>

<pre><code class="javascript">var testSuiteConstructor = FizzBuzzKataTest;
var testSuite = new testSuiteConstructor(assertions);
testSuite.testNormalNumberIsReturned();
</code></pre>

<p>and extract method:</p>

<pre><code class="javascript">function runTestSuite(testSuiteConstructor) {
    var testSuite = new testSuiteConstructor(assertions);
    testSuite.testNormalNumberIsReturned();
}

var testSuiteConstructor = FizzBuzzKataTest;
runTestSuite(testSuiteConstructor);
</code></pre>

<p>and inline the variable <code>testSuiteConstructor</code>:</p>

<pre><code class="javascript">runTestSuite(FizzBuzzKataTest);
</code></pre>

<p>Now it is time to move testing code to <code>src/TestingFramework.js</code>:</p>

<pre><code class="javascript">// src/TestingFramework.js

var assertions = {
    assertTrue: function (condition, message) {
        if (!condition) {
            throw new Error(message || "Expected to be true, but got false");
        }
    }
};

function runTestSuite(testSuiteConstructor) {
    var testSuite = new testSuiteConstructor(assertions);
    testSuite.testNormalNumberIsReturned();
}
</code></pre>

<p>And to be able to require <code>runTestSuite</code> function:</p>

<pre><code class="javascript">// src/TestingFramework.js

var assertions = { ... };

function runTestSuite(testSuiteConstructor) { ... }

module.exports = runTestSuite;
</code></pre>

<p>And, finally, let&rsquo;s use that from our test suite:</p>

<pre><code class="javascript">// test/FizzBuzzKataTest.js

var runTestSuite = require("../src/TestingFramework");

function FizzBuzzKataTest(t) { ... }

function fizzBuzz(number) { ... }

runTestSuite(FizzBuzzKataTest);
</code></pre>

<p>If we run the test suite again, everything should pass. Somehow, I don&rsquo;t feel comfortable now, let&rsquo;s try to break the test suite and see if it will fail as expected:</p>

<pre><code class="javascript">function fizzBuzz(number) {
    return "2";  // &lt;-- "1" was changed to "2" here
}
</code></pre>

<p>And run tests:</p>

<pre><code>/path/to/project/src/TestingFramework.js:4
            throw new Error(message || "Expected to be true, but got false");
            ^

Error: Expected to equal 1, but got: 2
</code></pre>

<p>Yes, it still works as expected. We have just introduced a Mutation to our code, to see if it is still tested properly. Let&rsquo;s undo the Mutation and see the test still pass. And it does.</p>

<p>If you look closely now, it should be possible to inline <code>FizzBuzzKataTest</code> definition as an argument of <code>runTestSuite</code> call:</p>

<pre><code class="javascript">var runTestSuite = require(...);

function fizzBuzz(number) { ... }

runTestSuite(function (t) { ... });
</code></pre>

<p>And if we run our test suite, it still works. Just to check, that we are still good, let&rsquo;s repeat our Mutation from the previous step. It should still fail as expected. And it does. Undo the mutation and the test is still passing. Great.</p>

<p>I think we are done with Refactoring step, for now, let&rsquo;s get back to writing another failing test.</p>

<h2>Writing the second test</h2>

<pre><code class="javascript">    this.testAnotherNormalNumberIsReturned = function() {
        t.assertTrue("2" === fizzBuzz(2), "Expected to equal " + "2" + ", but got: " + fizzBuzz(2));
    };
</code></pre>

<p>If we run these tests, they do not fail. This is strange, let&rsquo;s look at <code>runTestSuite</code> function again:</p>

<pre><code class="javascript">function runTestSuite(testSuiteConstructor) {
    var testSuite = new testSuiteConstructor(assertions);
    testSuite.testNormalNumberIsReturned();
}
</code></pre>

<p>Great, it just runs one specific function, we should probably run all functions starting from <code>test</code> instead:</p>

<pre><code class="javascript">function runTestSuite(testSuiteConstructor) {
    var testSuite = new testSuiteConstructor(assertions);

    for (var testName in testSuite) {
        if (testName.match(/^test/)) {
            testSuite[testName]();
        }
    }
}
</code></pre>

<p><em>REMARK: this code is Javascript specific. Other programming languages will have their own way of iterating over the function/method list and calling a function by its name. Usually, it is some sort of reflection for compiled languages and meta-programming features for interpreted languages.</em></p>

<p>If we run tests now, we get the expected failure:</p>

<pre><code>/path/to/project/src/TestingFramework.js:4
            throw new Error(message || "Expected to be true, but got false");
            ^

Error: Expected to equal 2, but got: 1
</code></pre>

<p>If we try to change <code>return "1"</code> to <code>return "2"</code>, of course this test will pass, but the other will fail:</p>

<pre><code>/path/to/project/src/TestingFramework.js:4
            throw new Error(message || "Expected to be true, but got false");
            ^

Error: Expected to equal 1, but got: 2
</code></pre>

<p>This is great for couple of reasons:</p>

<ul>
<li>It validates, that our change to how <code>test*</code> functions are discovered is correct, and</li>
<li>We have to have a bit smarter implementation to pass both tests now:</li>
</ul>


<pre><code class="javascript">function fizzBuzz(number) {
    return number.toString();
}
</code></pre>

<p>And if we run the tests, they pass. Now, that we are in Green state, we should start refactoring. Have you noticed the duplication already?</p>

<pre><code class="javascript">t.assertTrue("1" === fizzBuzz(1), "Expected to equal " + "1" + ", but got: " + fizzBuzz(1));

// and:

t.assertTrue("2" === fizzBuzz(2), "Expected to equal " + "2" + ", but got: " + fizzBuzz(2));
</code></pre>

<p>Extracting <code>"1"</code> and <code>"2"</code> as variable <code>expected</code>, and <code>fizzBuzz(1)</code> and <code>fizzBuzz(2)</code> as variable <code>actual</code>, makes these 2 lines identical:</p>

<pre><code class="javascript">this.testNormalNumberIsReturned = function () {
    var expected = "1";
    var actual = fizzBuzz(1);
    t.assertTrue(expected === actual, "Expected to equal " + expected + ", but got: " + actual);
};

this.testAnotherNormalNumberIsReturned = function() {
    var expected = "2";
    var actual = fizzBuzz(2);
    t.assertTrue(expected === actual, "Expected to equal " + expected + ", but got: " + actual);
};
</code></pre>

<p>Specifically, this is identical:</p>

<pre><code class="javascript">t.assertTrue(expected === actual, "Expected to equal " + expected + ", but got: " + actual);
</code></pre>

<p>This sounds like <code>t.assertEqual(expected, actual)</code> to me. So let&rsquo;s extract it:</p>

<pre><code class="javascript">// src/TestingFramework.js

var assertions = {
    assertTrue: function(condition, message) { ... },

    assertEqual: function(expected, actual) {
        this.assertTrue(
          expected === actual,
          "Expected to equal " + expected + ", but got: " + actual
        );
    }
}
</code></pre>

<p>Now, let&rsquo;s use it and inline our <code>expected</code> and <code>actual</code> variables:</p>

<pre><code class="javascript">this.testNormalNumberIsReturned = function () {
    t.assertEqual("1", fizzBuzz(1));
};

this.testAnotherNormalNumberIsReturned = function() {
    t.assertEqual("2", fizzBuzz(2));
};
</code></pre>

<p>This looks much more readable. If we run tests, they still pass. If we try to break our code by using some Mutation, the tests fail as expected. Great, our refactoring was a success!</p>

<p>Let&rsquo;s finish test-driving our <code>fizzBuzz</code> function.</p>

<h2>Test-Driving Fizz Buzz Kata</h2>

<p>First test for <code>Fizz</code> case:</p>

<pre><code class="javascript">// test:
this.testFizzIsReturned = function () {
    t.assertEqual("Fizz", fizzBuzz(3));
};

// Error: Expected to equal Fizz, but got: 3

// implementation:
function fizzBuzz(number) {
    if (number === 3) return "Fizz";
    return number.toString();
}
</code></pre>

<p>This is pretty stupid implementation, but it works for that one tests, so let&rsquo;s write the test, that will break this implementation and force us to write real <code>if</code> condition:</p>

<pre><code class="javascript">// test:
this.testFizzIsReturnedForDifferentNumber = function () {
    t.assertEqual("Fizz", fizzBuzz(6));
};

// Error: Expected to equal Fizz, but got: 6

// implementation:
function fizzBuzz(number) {
    if (number % 3 === 0) return "Fizz";
    return number.toString();
}
</code></pre>

<p>This technique is called Triangulation:</p>

<ul>
<li>the first test is to force us to write some <code>if</code> statement with a correct body,</li>
<li>second is to force us to make the condition right.</li>
<li>If we had an <code>else</code> clause, we would have had another test to make that part right.</li>
</ul>


<p>OK, that looks like a right implementation for <code>Fizz</code>, let&rsquo;s write the test for <code>Buzz</code> now:</p>

<pre><code class="javascript">// test:
this.testBuzzIsReturned = function () {
    t.assertEqual("Buzz", fizzBuzz(5));
};

// Error: Expected to equal Buzz, but got: 5

// stupid implementation:
function fizzBuzz(number) {
    if (number === 5) return "Buzz";
    if (number % 3 === 0) return "Fizz";
    return number.toString();
}

// Triangulation:
this.testBuzzIsReturnedForDifferentNumber = function () {
    t.assertEqual("Buzz", fizzBuzz(10));
};

// Error: Expected to equal Buzz, but got: 10

// correct implementation:
function fizzBuzz(number) {
    if (number % 5 === 0) return "Buzz";
    if (number % 3 === 0) return "Fizz";
    return number.toString();
}
</code></pre>

<p>And finally let&rsquo;s implement final requirement <code>FizzBuzz</code>:</p>

<pre><code class="javascript">// test:
this.testFizzBuzzIsReturned = function () {
    t.assertEqual("FizzBuzz", fizzBuzz(15));
};

// Error: Expected to equal FizzBuzz, but got: Buzz

// stupid implementation:
function fizzBuzz(number) {
    if (number === 15) return "FizzBuzz";
    if (number % 5 === 0) return "Buzz";
    if (number % 3 === 0) return "Fizz";
    return number.toString();
}

// Triangulation:
this.testFizzBuzzIsReturnedForDifferentNumber = function () {
    t.assertEqual("FizzBuzz", fizzBuzz(30));
};

// Error: Expected to equal FizzBuzz, but got: Buzz

// correct implementation:
function fizzBuzz(number) {
    if (number % 15 === 0) return "FizzBuzz";
    if (number % 5 === 0) return "Buzz";
    if (number % 3 === 0) return "Fizz";
    return number.toString();
}
</code></pre>

<p>I think we are done with the implementation. <code>FizzBuzzKata</code> has an extended set of requirements, but they are out of the scope of this article. These requirements force us to introduce Strategy pattern and stop using this unmaintainable chain of <code>if</code> statements.</p>

<p>Refactoring this code to Strategy pattern is left as an exercise for the reader.</p>

<h2>Bottom Line</h2>

<p>Congratulations! Using <code>FizzBuzzKata</code> we have test-driven bare-bones testing framework to the point, that we can do Test-Driven Development for a simple Kata. And all that without having any testing framework in place.</p>

<p>The code is available on Github: <a href="https://github.com/waterlink/BuildYourOwnTestingFrameworkPart1">https://github.com/waterlink/BuildYourOwnTestingFrameworkPart1</a></p>

<p>Now, with this minimal framework in place, it should be possible to unit-test the framework itself, so that we can support more use cases. This will be covered in next series of &ldquo;Build Your Own Testing Framework&rdquo;. Stay tuned!</p>

<h2>Thanks!</h2>

<p>Thank you for reading, my dear reader. If you liked it, please share this article on social networks and follow me on twitter: <a href="https://twitter.com/waterlink000">@waterlink000</a>.</p>

<p>If you have any questions or feedback for me, don&rsquo;t hesitate to reach me out on Twitter: <a href="https://twitter.com/waterlink000">@waterlink000</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Why I Don't Use Mocking Frameworks Anymore]]></title>
    <link href="http://www.tddfellow.com/blog/2016/06/21/why-i-dont-use-mocking-frameworks-anymore/"/>
    <updated>2016-06-21T08:04:10+02:00</updated>
    <id>http://www.tddfellow.com/blog/2016/06/21/why-i-dont-use-mocking-frameworks-anymore</id>
    <content type="html"><![CDATA[<p>Some time ago, I have discovered, that using your own custom test double classes, instead of a test framework makes my test code more readable and maintainable. Here is an example (pseudo-code):</p>

<pre><code class="javascript">function test_password_revealer_when_toggled_reveals_password() {
  passwordController = MockPasswordController.new()
  passwordRevealer = PasswordRevealer.new(passwordController)

  passwordRevealer.toggle()

  expect(passwordController.isRevealed()).toBeTrue()
}
</code></pre>

<p>The same test with mocking framework would look this way:</p>

<pre><code class="javascript">function test_password_revealer_when_toggled_reveals_password() {
  passwordController = MockFramework.Mock.new("PasswordController")
  passwordRevealer = PasswordRevealer.new(passwordController)

  spy = spyOn(passwordController.reveal())

  passwordRevealer.toggle()

  expect(spy.haveBeenCalled()).toBeTrue()
}
</code></pre>

<p>If you take a closer look at the last example, and, specifically at these 2 lines:</p>

<pre><code class="javascript">spy = spyOn(passwordController.reveal())

expect(spy.haveBeenCalled()).toBeTrue()
</code></pre>

<p>They use a language, that is not relevant to the domain, therefore, they make the test less readable.</p>

<p>Additionally, they have knowledge of which exactly method <code>PasswordRevealer#toggle()</code> should call on <code>passwordController</code>. If we were to rename <code>reveal</code> method, all tests for <code>PasswordRevealer</code> would fail.
The same thing would happen if we were to extract methods/functions/objects out of the <code>PasswordRevealer</code>.</p>

<p>Of course, creating such test doubles yourself will involve some boilerplate code - this is a trade-off. Example:</p>

<pre><code class="javascript">class MockPasswordController() {
  this.state = "hidden"

  this.reveal() {
    this.state = "revealed"
  }

  this.hide() {
    this.state = "hidden"
  }

  this.isRevealed() {
    return this.state == "revealed"
  }
}
</code></pre>

<p>Making this trade-off, will simplify the case when we were to change the name: we would change the name at 3 places:</p>

<ul>
<li>in test double class,</li>
<li>in caller class,</li>
<li>in &ldquo;real&rdquo; implementation class.</li>
</ul>


<p>Whereas with a mocking framework, we would have to hunt for all failing tests, and usually, it means hundreds of failing tests.</p>

<h2>Thank you!</h2>

<p>If you, my dear reader, have any thoughts, questions or arguments about the topic, feel free to reach out to me on twitter: <a href="https://twitter.com/waterlink000">@waterlink000</a>.</p>

<p>If you liked my ideas, follow me on twitter, and, even better, provide me with your honest feedback, so that I can improve.</p>
]]></content>
  </entry>
  
</feed>
