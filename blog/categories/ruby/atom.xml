<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ruby | That TDD Fellow | Tech Blog | Screencasts]]></title>
  <link href="http://www.tddfellow.com/blog/categories/ruby/atom.xml" rel="self"/>
  <link href="http://www.tddfellow.com/"/>
  <updated>2016-08-31T15:36:58+02:00</updated>
  <id>http://www.tddfellow.com/</id>
  <author>
    <name><![CDATA[Oleksii Fedorov (waterlink)]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Getting Stuck While Doing TDD. Part 2: Buggy Code and Forcing Our Way Through]]></title>
    <link href="http://www.tddfellow.com/blog/2016/08/31/getting-stuck-while-doing-tdd-part-2-buggy-code-and-forcing-our-way-through/"/>
    <updated>2016-08-31T02:35:06+02:00</updated>
    <id>http://www.tddfellow.com/blog/2016/08/31/getting-stuck-while-doing-tdd-part-2-buggy-code-and-forcing-our-way-through</id>
    <content type="html"><![CDATA[<p>Welcome back to the &ldquo;Getting Stuck While Doing TDD&rdquo; series. Today we are going to see the results of getting stuck while doing TDD and scratch the surface of how to avoid this outcome.</p>

<p>Code examples today will be in Ruby programming language. The technique itself is, of course, language-agnostic.</p>

<h2>TL;DR</h2>

<ul>
<li>It is painful and difficult to force your way through when getting stuck in TDD.</li>
<li>It results in degraded guarantees from TDD (such as test coverage, semantical stability, and confidence).</li>
</ul>


<p>Ways to avoid this outcome:</p>

<ul>
<li>do not write tests that will not fail with the current production code</li>
<li>choose next test to write that will address particular detail about production code that is wrong or not general enough (Triangulation)</li>
</ul>


<p>Finally, do not forget to remove redundant tests if any.</p>

<p>This is a series of articles:</p>

<ol>
<li><a href="/blog/2016/08/30/getting-stuck-while-doing-tdd-part-1-example/">Part 1: Example</a></li>
<li>Part 2: Buggy Code and Forcing Our Way Through (reading this)</li>
<li>Part 3: Triangulation to the Rescue! (coming soon)</li>
</ol>


<h2>Buggy if-riddled code</h2>

<p>Buggy <code>if</code>-riddled code is what we&rsquo;ve got. It is even not so easy to read. While we can refactor it to be more readable that won&rsquo;t change the presence of bugs, though. Let&rsquo;s still do it to understand what happens in this code better:</p>

<pre><code class="ruby">class OrderKindValidator
  def validate(order)
    kinds = order[:kind]

    validate_only_known(kinds)
    validate_has_required(kinds)
    validate_no_conflicting(kinds)
    validate_non_empty(kinds)
  end

  private

  def validate_non_empty(kinds)
    if empty?(kinds)
      fail_with("Order kind can not be empty")
    end
  end

  def validate_no_conflicting(kinds)
    if has_conflicting(kinds)
      fail_with("Order kind can not be 'private' and 'corporate' at the same time")
    end
  end

  def validate_has_required(kinds)
    if has_no_required(kinds)
      fail_with("Order kind should be 'private' or 'corporate'")
    end
  end

  def validate_only_known(kinds)
    if invalid?(kinds)
      fail_with("Order kind can be one of: 'private', 'corporate', 'bundle'")
    end
  end

  def empty?(kind)
    kind != ["private"] &amp;&amp; kind != ["corporate"] &amp;&amp;
        kind != %w(private bundle) &amp;&amp;
        kind != %w(corporate bundle)
  end

  def has_conflicting(kind)
    kind == %w(private corporate)
  end

  def has_no_required(kind)
    kind == ["bundle"]
  end

  def invalid?(kind)
    kind == ["invalid"]
  end

  def fail_with(message)
    raise InvalidOrderError.new(message)
  end
end
</code></pre>

<p>Structure of the class, actually, sounds just right, but conditions are not good:</p>

<pre><code class="ruby">def empty?(kind)
  kind != ["private"] &amp;&amp; kind != ["corporate"] &amp;&amp;
      kind != %w(private bundle) &amp;&amp;
      kind != %w(corporate bundle)
end
</code></pre>

<p>Really? It does not do what it says. At all. It basically just solves the problem very specifically to the tests. I can easily come up with a test that will break it:</p>

<pre><code class="ruby">it_fails_with("Order kind can be one of: 'private', 'corporate', 'bundle'")
    .when_order_kind_is ["almost anything"]

# Error: expected InvalidOrderError with
#    "Order kind can be one of: 'private', 'corporate', 'bundle'",
# got #&lt;InvalidOrderError: Order kind can not be empty&gt;

# or other test
it_does_not_fail.when_order_kind_is %w(corporate corporate)
</code></pre>

<pre><code class="ruby">def has_conflicting(kind)
  kind == %w(private corporate)
end
</code></pre>

<p>This at least does what it says. But only for one specific case, instead of general one. One test that I can come up with right away:</p>

<pre><code class="ruby">it_fails_with("Order kind can not be 'private' and 'corporate' at the same time")
    .when_order_kind_is %w(private corporate bundle)

# and another one:
it_fails_with("Order kind can not be 'private' and 'corporate' at the same time")
    .when_order_kind_is %w(corporate private)
</code></pre>

<pre><code class="ruby">def has_no_required(kind)
  kind == ["bundle"]
end
</code></pre>

<p>While this may work for our current requirements, it is really confusing for the reader. Method name says: &ldquo;has no required kind&rdquo; while method body checks if it is only <code>bundle</code>. And it does not work well with that edge case:</p>

<pre><code class="ruby">it_fails_with("Order kind should be 'private' or 'corporate'")
    .when_order_kind_is %w(bundle bundle)
</code></pre>

<p>While this case is quite unlikely, nothing in business rules forbid that and some other part of the system may as well duplicate <code>bundle</code> kind for some reason or it may be a user input mistake.</p>

<pre><code class="ruby">def invalid?(kind)
  kind == ["invalid"]
end
</code></pre>

<p>This method, indeed, checks that <code>kind</code> is <code>invalid</code>. Literally <code>"invalid"</code>. Which would mean, that all kinds except exactly <code>"invalid"</code> are allowed. This is not true according to our business rules. In fact, we have already written the failing test for this some moments ago:</p>

<pre><code class="ruby">it_fails_with("Order kind can be one of: 'private', 'corporate', 'bundle'")
    .when_order_kind_is ["almost anything"]
</code></pre>

<p>Let&rsquo;s comment out these failing tests and try to force-TDD our way through these bugs by uncommenting and fixing them one-by-one following Red-Green-Refactor loop:</p>

<h2>Forcing our way through</h2>

<p>So, let&rsquo;s uncomment our first failing test:</p>

<pre><code class="ruby">it_fails_with("Order kind can be one of: 'private', 'corporate', 'bundle'")
    .when_order_kind_is ["almost anything"]
</code></pre>

<p>We are expecting <code>validate_only_known</code> to fail with its message and that means <code>invalid?(kinds)</code> should return true. To make it return <code>true</code> in this case and preserve its old behavior we will need to remove <code>private</code>, <code>corporate</code> and <code>bundle</code> from <code>kinds</code> and check that it is not empty:</p>

<pre><code class="ruby">def invalid?(kinds)
  (kinds - %w(private corporate bundle)).any?
end
</code></pre>

<p>See how we had to write the whole thing in one go. There is no chance to write it incrementally because there will be a bunch of tests that fail. Wait! While it does not fail for any tests related to invalid kinds, it fails for all tests related to emptiness:</p>

<pre><code>OrderKindValidator
  fails with message "Order kind can not be empty"
    when order kind is [""] (FAILED - 1)
    when order kind is ["", ""] (FAILED - 2)
    when order kind is ["private", ""] (FAILED - 3)
    when order kind is absent (FAILED - 4)
    when order kind is nil (FAILED - 5)
</code></pre>

<p>So we need to change more production code to make this one tiny test pass. It looks like <code>validate_non_empty</code> is a culprit now - it is being called after <code>validate_only_known</code>. It should be the other way around:</p>

<pre><code class="ruby">def validate(order)
  kinds = order[:kind]

  validate_non_empty(kinds)
# ^ we moved this up here ^

  validate_only_known(kinds)
  validate_has_required(kinds)
  validate_no_conflicting(kinds)
end
</code></pre>

<p>Oh! Now a bunch of other tests fails:</p>

<pre><code>OrderKindValidator
  fails with message "Order kind should be 'private' or 'corporate'"
    when order kind is ["bundle"] (FAILED - 1)

  fails with a message "Order kind can not be 'private' and 'corporate' at the same time"
    when order kind is ["private", "corporate"] (FAILED - 4)

  fails with a message "Order kind can be one of: 'private', 'corporate', 'bundle'"
    when order kind is ["almost anything"] (FAILED - 2)
    when order kind is ["invalid"] (FAILED - 3)
</code></pre>

<p>From failure messages it is possible to guess, that the culprit is <code>empty?(kinds)</code> function that fails in too much cases now, such as: <code>["bundle"]</code>, <code>["private", "corporate"]</code>, <code>["almost anything"]</code> and <code>["invalid"]</code>. This is because it was not doing what it said it was:</p>

<pre><code class="ruby">def empty?(kinds)
  kinds != ["private"] &amp;&amp; kinds != ["corporate"] &amp;&amp;
      kinds != %w(private bundle) &amp;&amp;
      kinds != %w(corporate bundle)
end
</code></pre>

<p>And this is why it was hard to change the order of validations. We will have to completely rewrite this function. Let&rsquo;s start small and see which tests fail:</p>

<pre><code class="ruby">def empty?(kinds)
  false
end
</code></pre>

<p>The failures are:</p>

<pre><code>OrderKindValidator
  fails with message "Order kind can not be empty"
    when order kind is ["private", ""] (FAILED - 1)
    when order kind is [nil] (FAILED - 2)
    when order kind is ["", ""] (FAILED - 3)
    when order kind is nil (FAILED - 4)
    when order kind is [""] (FAILED - 5)
    when order kind is absent (FAILED - 6)
    when order kind is [nil, nil] (FAILED - 7)
    when order kind is ["private", nil] (FAILED - 8)
    when order kind is [] (FAILED - 9)
</code></pre>

<p>Good, only tests related directly to this case are failing. So one-by-one we can construct our condition while fixing these test failures:</p>

<ol>
<li><code>kinds.nil?</code></li>
<li><code>|| kinds.empty?</code></li>
<li><code>|| kinds[0].nil?</code>   (turned out to be redundant in the end)</li>
<li><code>|| kinds[0].empty?</code> (turned out to be redundant in the end)</li>
<li><code>|| kinds.any? { |k| k.nil? || k.empty? }</code></li>
</ol>


<p>After refactoring <code>empty?</code> the function now is looking this way:</p>

<pre><code class="ruby">def empty?(kinds)
  absent_or_empty?(kinds) ||
      kinds.any? { |kind| absent_or_empty?(kind) }
end

def absent_or_empty?(value)
  value.nil? || value.empty?
end
</code></pre>

<p>And all tests, finally, pass. It took a lot of effort and re-writing to get this one little test to pass. This is what we call &ldquo;Getting Stuck&rdquo; in TDD. There is always an order of tests that will lead to this result almost for any somewhat complex problem.</p>

<p>The code can be found in GitHub repository in <a href="https://github.com/waterlink/order_kind_validator/pull/2/files">an open pull request here</a>.</p>

<p>Almost guaranteed ways to get stuck in TDD:</p>

<ul>
<li>write tests that do not fail,</li>
<li>do not address weird results of &ldquo;simplest thing that could possibly work&rdquo; to make the test pass and moving on to the next business rule,</li>
<li>make production code a mirror of the tests and too specific, not general.</li>
</ul>


<p>And to not get stuck is to do the opposite:</p>

<ul>
<li>do not write the test that will not fail (wait until later, when it will fail), and</li>
<li>always first write the test that will point out next deficiency in the current production code (in TDD this is called Triangulation), and</li>
<li>while making some failing test pass, make sure that the change in production code covers not only this one specific test, rather, a whole class of tests (Golden Rule of TDD: As tests get more specific, production code gets more generic).</li>
</ul>


<h2>Bottom Line</h2>

<p>Today we have seen how bad the results of getting stuck while doing TDD can be. In the next article of these series, we will explore Golden Rule of TDD and the technique called Triangulation, that allows us to incrementally test-drive code in a way, that it will always be conforming to the Golden Rule of TDD and therefore will never get us stuck. Stay tuned!</p>

<p>You would not want to miss next articles on this tech blog, we still have a lot to talk about:</p>

<ul>
<li>Triangulation technique in Test-Driven Development - overlooking this technique might cause one fail at doing TDD (these series),</li>
<li>Continuous Integration and Continuous Delivery - importance of not impeding others,</li>
<li>Open-Closed Principle - changing behavior by adding new code,</li>
<li>Mutational Testing, &ldquo;Build Your Own Testing Framework&rdquo; series, Test-Driven Development screencasts and so much more!</li>
</ul>


<h2>Thanks!</h2>

<p>Thank you for reading, my dear reader. If you liked it, please share this article on social networks and follow me on twitter: <a href="https://twitter.com/waterlink000">@waterlink000</a>.</p>

<p>If you have any questions or feedback for me, don&rsquo;t hesitate to reach me out on Twitter: <a href="https://twitter.com/waterlink000">@waterlink000</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Getting Stuck While Doing TDD. Part 1: Example]]></title>
    <link href="http://www.tddfellow.com/blog/2016/08/30/getting-stuck-while-doing-tdd-part-1-example/"/>
    <updated>2016-08-30T15:27:30+02:00</updated>
    <id>http://www.tddfellow.com/blog/2016/08/30/getting-stuck-while-doing-tdd-part-1-example</id>
    <content type="html"><![CDATA[<p>Following 3 rules of TDD sounds really simple at first. In practice, there is a moment when one has to implement the whole algorithm at once to make currently failing test pass. This is called &ldquo;getting stuck&rdquo; in TDD. In this article, we will explore how exactly this happens and how to prevent that.</p>

<p>Code examples today will be in Ruby programming language. The technique itself is, of course, language-agnostic.</p>

<h2>TL;DR</h2>

<p>&ldquo;Getting stuck&rdquo; happens for a couple of reasons:</p>

<ul>
<li>wrong order of tests</li>
<li>production code is not getting more general with each test</li>
</ul>


<p>This is a series of articles:</p>

<ol>
<li>Part 1: Example (reading this)</li>
<li><a href="/blog/2016/08/31/getting-stuck-while-doing-tdd-part-2-buggy-code-and-forcing-our-way-through/">Part 2: Buggy Code and Forcing Our Way Through</a></li>
<li>Part 3: Triangulation to the Rescue! (coming soon)</li>
</ol>


<h2>&ldquo;Getting Stuck&rdquo; in TDD</h2>

<p>Usually &ldquo;Getting Stuck&rdquo; follows this pattern:</p>

<ul>
<li>write some test and implement it via &ldquo;simplest thing that might possibly work&rdquo;,</li>
<li>write another test and implement it again in a non-general manner,</li>
<li>write some more tests in that fashion, while never addressing the fact that production code now looks completely wrong from what it should probably be looking like,</li>
<li>write a new test, that forces us to completely rewrite production code in a complete algorithm just to make it pass.</li>
</ul>


<p>This last step usually takes minutes to hours depending on the complexity of the problem at hand. Additionally, the first few tests are basically wasted time since they did not produce any bits of knowledge in the production code that persisted in production code in the end. Even worse, chances are that the algorithm that we have just written is not fully covered by current tests, since we have written it in one go just to make current failing test pass - this is no longer correct TDD and can not guarantee high test coverage, and, therefore, can not guarantee high confidence anymore.</p>

<p>Let&rsquo;s go through a small example on how one can get stuck in TDD:</p>

<h2>Order Kind Validation - Getting Stuck</h2>

<p>Let&rsquo;s define the problem at hand first. We have some sort of order request as an input to our system and we need to validate that its kind is correct:</p>

<ul>
<li>valid order kinds: <code>private</code>, <code>corporate</code>, <code>bundle</code>,</li>
<li>order kinds can be combined,</li>
<li><code>private</code> and <code>corporate</code> order kinds can not be combined, otherwise <code>InvalidOrderError</code> with message <code>Order kind can not be 'private' and 'corporate' at the same time</code>,</li>
<li>either <code>private</code> or <code>corporate</code> should be always present, otherwise <code>InvalidOrderError</code> with message <code>Order kind should be 'private' or 'corporate'</code>,</li>
<li>if order kind is not in the above list, then we need to raise <code>InvalidOrderError</code> with message <code>Order kind can be one of: 'private', 'corporate', 'bundle'</code>,</li>
<li>if order kind is not present or an empty string, then we need to raise <code>InvalidOrderError</code> with message <code>Order kind can not be empty</code>.</li>
</ul>


<p>This is a fairly simple problem and it is easy to get stuck while doing TDD here. So let&rsquo;s write our first test: &ldquo;When order has no order_kind, then we should get InvalidOrderError with message &lsquo;Order kind can not be empty&rsquo;&rdquo;:</p>

<pre><code class="ruby">RSpec.describe OrderKindValidator do
  it "fails with a message about order kind being empty when it is absent" do
    validator = OrderKindValidator.new

    expect { validator.validate({ items: 42 }) }
        .to raise_error(InvalidOrderError, "Order kind can not be empty")
  end
end
</code></pre>

<p>And the simplest implementation possible:</p>

<pre><code class="ruby">class OrderKindValidator
  def validate(order)
    raise InvalidOrderError.new("Order kind can not be empty")
  end
end

class InvalidOrderError &lt; StandardError
end
</code></pre>

<p>Next test is our next simplest edge case - when kind&rsquo;s value is <code>nil</code>:</p>

<pre><code class="ruby">it "fails with a message about order kind being empty when it is nil" do
  validator = OrderKindValidator.new

  expect { validator.validate({items: 42, kind: nil }) }
      .to raise_error(InvalidOrderError, "Order kind can not be empty")
end
</code></pre>

<p>It does not fail at all, so we don&rsquo;t have any reason to change the production code. We can already spot a little duplication - <code>validator</code> variable. Let&rsquo;s extract it as a named subject of the test suite:</p>

<pre><code class="ruby">subject(:validator) { OrderKindValidator.new }
</code></pre>

<p>And <code>OrderKindValidator</code> can be replaced with <code>described_class</code> (RSpec feature), so that we will not have to change too much in case we wanted to change name of the class:</p>

<pre><code class="ruby">subject(:validator) { described_class.new }
</code></pre>

<p>Next simplest edge case - when kind is an empty array:</p>

<pre><code class="ruby">it "fails with a message about order kind being empty when it has zero elements" do
  expect { validator.validate({items: 42, kind: [] }) }
      .to raise_error(InvalidOrderError, "Order kind can not be empty")
end
</code></pre>

<p>I believe I am spotting annoying pattern now:</p>

<pre><code class="ruby">it "fails with message MESSAGE when it is KIND_CASE" do
  expect { validator.validate({items: 42, kind: KIND_VALUE}) }
    .to raise_error(InvalidOrderError, MESSAGE)
end
</code></pre>

<p>It would be really nice to write it in this fashion:</p>

<pre><code class="ruby">it_fails_with("Order kind can not be empty").when_order_kind_is_absent
it_fails_with("Order kind can not be empty").when_order_kind_is nil
it_fails_with("Order kind can not be empty").when_order_kind_is []
</code></pre>

<p>And as another duplication piles up:</p>

<pre><code class="ruby">it_fails_with_order_kind_not_empty = it_fails_with("Order kind can not be empty")

it_fails_with_order_kind_not_empty.when_order_kind_is_absent
it_fails_with_order_kind_not_empty.when_order_kind_is nil
it_fails_with_order_kind_not_empty.when_order_kind_is []
</code></pre>

<p>Now the next tests look very easy and simple:</p>

<pre><code class="ruby">it_fails_with_order_kind_not_empty.when_order_kind_is [nil]
it_fails_with_order_kind_not_empty.when_order_kind_is [""]
it_fails_with_order_kind_not_empty.when_order_kind_is [nil, nil]
it_fails_with_order_kind_not_empty.when_order_kind_is ["", ""]
it_fails_with_order_kind_not_empty.when_order_kind_is ["private", ""]
it_fails_with_order_kind_not_empty.when_order_kind_is ["private", nil]
</code></pre>

<p>And they all pass right from the go. The implementation for the <code>it_fails_with</code> is looking like this:</p>

<pre><code class="ruby">RSpec.describe OrderKindValidator do
  class ItFailsWith
    def initialize(spec, expected_message)
      @spec = spec
      @expected_message = expected_message
    end

    def when_order_kind_is_absent
      expect_failure("absent", {items: 42})
    end

    def when_order_kind_is(value)
      expect_failure(value.inspect, {items: 42, kind: value})
    end

    private

    def expect_failure(feature, order, expected_message = @expected_message)
      @spec.it("fails with message #{expected_message.inspect} when order kind is #{feature}") do
        expect { validator.validate(order) }
            .to raise_error(InvalidOrderError, expected_message)
      end
    end
  end

  def self.it_fails_with(message)
    ItFailsWith.new(self, message)
  end
end
</code></pre>

<p>So, let&rsquo;s write our next edge case - when order kind is invalid:</p>

<pre><code class="ruby">it_fails_with("Order kind can be one of: 'private', 'corporate', 'bundle'")
    .when_order_kind_is ["invalid"]
</code></pre>

<p>Pretty neat! And oh, it fails:</p>

<pre><code>expected InvalidOrderError with
  "Order kind can be one of: 'private', 'corporate', 'bundle'",
got #&lt;InvalidOrderError: Order kind can not be empty&gt;
</code></pre>

<p>And the fix:</p>

<pre><code class="ruby">def validate(order)
  if order[:kind] == ["invalid"]
    raise InvalidOrderError.new(
        "Order kind can be one of: 'private', 'corporate', 'bundle'"
    )
  end

  raise InvalidOrderError.new("Order kind can not be empty")
end
</code></pre>

<p>Let&rsquo;s write our next test - when order kind is <code>private</code>:</p>

<pre><code class="ruby">it_does_not_fail.when_order_kind_is ["private"]
</code></pre>

<p>This fails as expected with <code>expected no Exception, got #&lt;InvalidOrderError: Order kind can not be empty&gt;</code>. And to make it pass we need to wrap second <code>raise</code> statement in the <code>if</code> condition:</p>

<pre><code class="ruby">if order[:kind] != ["private"]
  raise InvalidOrderError.new("Order kind can not be empty")
end
</code></pre>

<p>The implementation for <code>it_does_not_fail</code> looks like that:</p>

<pre><code class="ruby">class ItDoesNotFail
  def initialize(spec)
    @spec = spec
  end

  def when_order_kind_is(value)
    @spec.it("does not fail when order kind is #{value.inspect}") do
      expect { validator.validate({items: 42, kind: value}) }
        .not_to raise_error
    end
  end
end

def self.it_does_not_fail
  ItDoesNotFail.new(self)
end
</code></pre>

<p>Let&rsquo;s write our next test:</p>

<pre><code class="ruby">it_does_not_fail.when_order_kind_is ["corporate"]
</code></pre>

<p>And it fails with the expected error: <code>expected no Exception, got #&lt;InvalidOrderError: Order kind can not be empty&gt;</code>. The fix is to amend our <code>if</code> condition with that case:</p>

<pre><code class="ruby">if order[:kind] != ["private"] &amp;&amp; order[:kind] != ["corporate"]
                                # ^  we have added this case  ^
  raise InvalidOrderError.new("Order kind can not be empty")
end
</code></pre>

<p>And the tests pass. Our next business rule is that one of <code>private</code> and <code>corporate</code> should be always present:</p>

<pre><code class="ruby">it_fails_with("Order kind should be 'private' or 'corporate'")
    .when_order_kind_is ["bundle"]
</code></pre>

<p>As expected the test fails:</p>

<pre><code>expected InvalidOrderError with
  "Order kind should be 'private' or 'corporate'",
got #&lt;InvalidOrderError: Order kind can not be empty&gt;
</code></pre>

<p>And to fix it we just need to sprinkle another <code>if</code> statement in the middle of the function:</p>

<pre><code class="ruby">if order[:kind] == ["bundle"]
  raise InvalidOrderError.new("Order kind should be 'private' or 'corporate'")
end
</code></pre>

<p>As expected, the test passes. Now we should test the next business rule - order can not be of <code>private</code> and <code>corporate</code> kind at the same time:</p>

<pre><code class="ruby">it_fails_with("Order kind can not be 'private' and 'corporate' at the same time")
    .when_order_kind_is %w(private corporate)
</code></pre>

<p>This, as expected, fails with error message:</p>

<pre><code>expected InvalidOrderError with
  "Order kind can not be 'private' and 'corporate' at the same time",
got #&lt;InvalidOrderError: Order kind can not be empty&gt;
</code></pre>

<p>And easiest way to fix that is to add another <code>if</code> statement:</p>

<pre><code class="ruby">if order[:kind] == %w(private corporate)
  raise InvalidOrderError.new(
      "Order kind can not be 'private' and 'corporate' at the same time"
  )
end
</code></pre>

<p>And it passes. Let&rsquo;s test that we can combine <code>private</code> or <code>corporate</code> with <code>bundle</code> order kinds:</p>

<pre><code class="ruby">it_does_not_fail.when_order_kind_is %w(private bundle)
</code></pre>

<p>And it fails with error: <code>expected no Exception, got #&lt;InvalidOrderError: Order kind can not be empty&gt;</code>. To fix this we will have to amend our last <code>if</code> condition in the function even more:</p>

<pre><code class="ruby">if order[:kind] != ["private"] &amp;&amp; order[:kind] != ["corporate"] &amp;&amp;
    order[:kind] != %w(private bundle)
  # ^    this is our new condition    ^
  raise InvalidOrderError.new("Order kind can not be empty")
end
</code></pre>

<p>And the test passes. Let&rsquo;s refactor the code a bit:</p>

<ul>
<li>First, we should extract <code>order[:kind]</code> duplication to a local variable <code>kind</code></li>
<li>Extract common parts of <code>raise</code> statement to the private method</li>
</ul>


<p>After this, <code>OrderKindValidator</code> will look a bit cleaner:</p>

<pre><code class="ruby">class OrderKindValidator
  def validate(order)
    kind = order[:kind]

    if kind == ["invalid"]
      fail_with("Order kind can be one of: 'private', 'corporate', 'bundle'")
    end

    if kind == ["bundle"]
      fail_with("Order kind should be 'private' or 'corporate'")
    end

    if kind == %w(private corporate)
      fail_with("Order kind can not be 'private' and 'corporate' at the same time")
    end

    if kind != ["private"] &amp;&amp; kind != ["corporate"] &amp;&amp;
        kind != %w(private bundle)
      fail_with("Order kind can not be empty")
    end
  end

  private

  def fail_with(message)
    raise InvalidOrderError.new(message)
  end
end
</code></pre>

<p>Let&rsquo;s write our next test for the same business rule (now a corporate bundle):</p>

<pre><code class="ruby">it_does_not_fail.when_order_kind_is %w(corporate bundle)
</code></pre>

<p>And it fails with error: <code>expected no Exception, got #&lt;InvalidOrderError: Order kind can not be empty&gt;</code>. To fix this we need to add <code>&amp;&amp; kind != %w(corporate bundle)</code> to our last <code>if</code> condition again.</p>

<p>The code can be found in GitHub repository in <a href="https://github.com/waterlink/order_kind_validator/pull/1/files">an open pull request here</a>.</p>

<p>Now it seems that we have implemented all the business rules (we have all tests for them). Or did we?</p>

<h2>Bottom Line</h2>

<p>Buggy <code>if</code>-riddled code is what we&rsquo;ve got. We will see why in the next part of &ldquo;Getting Stuck While Doing TDD&rdquo; series. Stay tuned!</p>

<p>Today we have implemented our not-so-complex problem at hand while following 3 rules of TDD. The result was not of the best quality and we will take a look why in further articles of these series. You would not want to miss next articles on this tech blog, we still have a lot to talk about:</p>

<ul>
<li>Triangulation technique in Test-Driven Development - overlooking this technique might cause one fail at doing TDD (these series),</li>
<li>Continuous Integration and Continuous Delivery - importance of not impeding others,</li>
<li>Open-Closed Principle - changing behavior by adding new code,</li>
<li>Mutational Testing, &ldquo;Build Your Own Testing Framework&rdquo; series, Test-Driven Development screencasts and so much more!</li>
</ul>


<h2>Thanks!</h2>

<p>Thank you for reading, my dear reader. If you liked it, please share this article on social networks and follow me on twitter: <a href="https://twitter.com/waterlink000">@waterlink000</a>.</p>

<p>If you have any questions or feedback for me, don&rsquo;t hesitate to reach me out on Twitter: <a href="https://twitter.com/waterlink000">@waterlink000</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Using contracts.ruby With RSpec. Part 2]]></title>
    <link href="http://www.tddfellow.com/blog/2015/08/31/using-contracts-dot-ruby-with-rspec-part-2/"/>
    <updated>2015-08-31T18:36:30+02:00</updated>
    <id>http://www.tddfellow.com/blog/2015/08/31/using-contracts-dot-ruby-with-rspec-part-2</id>
    <content type="html"><![CDATA[<p>Remember <a href="http://waterlink.github.io/blog/2015/04/09/using-contracts-dot-ruby-with-rspec/">Using contracts.ruby With RSpec</a> ?</p>

<p>RSpec mocks violate all <code>:class</code> contracts because <code>is_a?(ClassName)</code> returns
<code>false</code> for mock. That post describes 2 possible solutions:</p>

<ul>
<li>stub <code>:is_a?</code>: <code>allow(my_double).to receive(:is_a?).with(MyClass).and_return(true)</code>, or</li>
<li>use <code>contracts-rspec</code> gem, that patches <code>instance_double</code> RSpec helper.</li>
</ul>


<h2>Custom validators</h2>

<p>Since custom validators have finally landed here:
<a href="https://github.com/egonSchiele/contracts.ruby/pull/159">egonShiele/contracts.ruby#159</a>,
now you can just override <code>:class</code> validator to accept all RSpec mocks:</p>

<pre><code class="ruby"># Make contracts accept all RSpec doubles
Contract.override_validator(:class) do |contract|
  lambda do |arg|
    arg.is_a?(RSpec::Mocks::Double) ||
      arg.is_a?(contract)
  end
end
</code></pre>

<p>Now, RSpec mocks will not violate all the <code>:class</code> contracts.</p>

<p>More information can be found here: <a href="https://github.com/egonSchiele/contracts.ruby/blob/v0.11.0/TUTORIAL.md#providing-your-own-custom-validators">Providing your own custom validators</a>.</p>

<p>Additionally this refactoring enabled valuable speed optimization for complex
contracts - validators for them will be evaluated only once and memoized.</p>

<h2>Links</h2>

<ul>
<li><a href="http://waterlink.github.io/blog/2015/04/09/using-contracts-dot-ruby-with-rspec/">Previous part</a></li>
<li>contracts.ruby: <a href="https://github.com/egonSchiele/contracts.ruby">https://github.com/egonSchiele/contracts.ruby</a></li>
<li>contracts.ruby chat: <a href="https://gitter.im/egonSchiele/contracts.ruby">https://gitter.im/egonSchiele/contracts.ruby</a></li>
<li>Mentioned PR: <a href="https://github.com/egonSchiele/contracts.ruby/pull/159">https://github.com/egonSchiele/contracts.ruby/pull/159</a></li>
<li><a href="http://waterlink.github.io/blog/2015/03/05/introduction-to-contracts-dot-ruby/">Introduction to contracts.ruby</a></li>
<li><a href="https://egonschiele.github.io/contracts.ruby/">Great contracts.ruby tutorial</a></li>
<li><a href="https://github.com/egonSchiele/contracts.ruby/pull/195">Full fledged documentation PR</a>: see here staging docs: <a href="https://relishapp.com/contracts-staging/contracts-ruby/docs">https://relishapp.com/contracts-staging/contracts-ruby/docs</a></li>
</ul>


<h2>Thanks!</h2>

<p>If you have any questions, suggestions or just want to chat about how
contracts.ruby is awesome, you can ping me on twitter
<a href="https://twitter.com/waterlink000">@waterlink000</a>. If you have any issues using
<a href="https://github.com/egonSchiele/contracts.ruby">contracts.ruby</a> you can create
issues on corresponding github project. Pull requests are welcome!</p>

<p>Comments on <a href="https://news.ycombinator.com/item?id=10147783">hackernews</a>.</p>

<p>Happy coding! <a href="https://twitter.com/waterlink000">@waterlink000 on twitter</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Running Kitchen-docker Tests With Upstart]]></title>
    <link href="http://www.tddfellow.com/blog/2015/08/05/running-kitchen-docker-tests-with-upstart/"/>
    <updated>2015-08-05T19:10:36+02:00</updated>
    <id>http://www.tddfellow.com/blog/2015/08/05/running-kitchen-docker-tests-with-upstart</id>
    <content type="html"><![CDATA[<p>TL;DR:</p>

<pre><code class="yml .kitchen.yml"># .kitchen.yml
---
driver:
  name: docker
  use_sudo: false              # this depends if you need to do `sudo` to run `docker` command or not
  disable_upstart: false
  image: ubuntu-upstart:14.04
  run_command: /sbin/init

platforms:
  - name: ubuntu-14.04
</code></pre>

<p>It is possible because there is this official base image specifically for upstart: <a href="https://registry.hub.docker.com/_/ubuntu-upstart/.">https://registry.hub.docker.com/_/ubuntu-upstart/.</a></p>

<p>After making your <code>.kitchen.yml</code> look like this, just use <code>kitchen</code> as you would normally would.</p>

<p>Happy coding! <a href="https://twitter.com/waterlink000">@waterlink000 on twitter</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Using contracts.ruby With RSpec]]></title>
    <link href="http://www.tddfellow.com/blog/2015/04/09/using-contracts-dot-ruby-with-rspec/"/>
    <updated>2015-04-09T21:51:53+02:00</updated>
    <id>http://www.tddfellow.com/blog/2015/04/09/using-contracts-dot-ruby-with-rspec</id>
    <content type="html"><![CDATA[<h2>Issues with RSpec mocks</h2>

<p>Lets start from example:</p>

<pre><code class="ruby">class Example
  include Contracts

  Contract Something =&gt; Any
  def do_something(something)
    something.call
  end
end
</code></pre>

<p>And its corresponding spec:</p>

<pre><code class="ruby">require "rspec"

RSpec.describe Example do
  let(:example) { Example.new }
  let(:something) { instance_double(Something, call: :hello) }

  it "works" do
    expect(example.do_something(something))
      .to eq(:hello)
  end
end
</code></pre>

<p>Pretty straightforward unit test for <code>Example#do_something</code>. But if you run <code>rspec</code> you will get:</p>

<pre><code>ContractError: Contract violation for argument 1 of 1:
    Expected: Something,
    Actual: #&lt;RSpec::Mocks::InstanceVerifyingDouble:0xa401a0 @name="Something (instance)"&gt;
    Value guarded in: Example::do_something
    With Contract: Something =&gt; Any
</code></pre>

<p>It happens because class contracts use <code>#is_a?</code> to determine if contract matches or not. Simply: <code>something.is_a?(Something)</code> is required to be <code>true</code>.</p>

<p>But if we try to do it with <code>instance_double</code>, that is what we get:</p>

<pre><code class="ruby">require "rspec/mocks/standalone"
something = instance_double(Something)
something.is_a?(Something)                              #=&gt; false
something.is_a?(RSpec::Mocks::InstanceVerifyingDouble)  #=&gt; true
</code></pre>

<h2>Solution to problem</h2>

<p>Pretty straightforward one:</p>

<pre><code class="ruby">let(:something) { instance_double(Something, call: :hello) }

before do
  allow(something)
    .to receive(:is_a?)
    .with(Something)
    .and_return(true)
end
</code></pre>

<p>But this can be boring to type it each time you need an <code>instance_double</code> while working with <code>contracts</code>. So here you go:</p>

<pre><code class="ruby"># Gemfile
group :test do
  gem "contracts-rspec"
end
</code></pre>

<p>Run <code>bundle</code> to install <code>contracts-rspec</code> gem.</p>

<pre><code class="ruby"># your spec file
require "contracts/rspec"

RSpec.describe Example do
  include Contracts::RSpec::Mocks

  # .. write code as in first example ..
end
</code></pre>

<p>Now you are covered. Inclusion of <code>Contracts::RSpec::Mocks</code> slightly alters behavior of <code>instance_double</code>. Now it automatically stubs out <code>#is_a?(Klass)</code> to return <code>true</code> on the class it was created from. In our case <code>Something</code>. This happens here: <a href="https://github.com/waterlink/contracts-rspec/blob/master/lib/contracts/rspec/mocks.rb#L4-L8">https://github.com/waterlink/contracts-rspec/blob/master/lib/contracts/rspec/mocks.rb#L4-L8</a></p>

<p>You can include it only in contexts you need, or you can do it globally from <code>spec_helper</code> like you do usually include spec helpers.</p>

<h2>Links</h2>

<ul>
<li>Gem: <a href="https://github.com/waterlink/contracts-rspec">https://github.com/waterlink/contracts-rspec</a></li>
<li>contracts.ruby: <a href="https://github.com/egonSchiele/contracts.ruby">https://github.com/egonSchiele/contracts.ruby</a></li>
<li>contracts.ruby chat: <a href="https://gitter.im/egonSchiele/contracts.ruby">https://gitter.im/egonSchiele/contracts.ruby</a></li>
<li>Born from here: <a href="https://github.com/egonSchiele/contracts.ruby/issues/14">egonSchiele/contracts.ruby#14</a></li>
<li><a href="http://waterlink.github.io/blog/2015/03/05/introduction-to-contracts-dot-ruby/">Introduction to contracts.ruby</a></li>
<li><a href="https://egonschiele.github.io/contracts.ruby/">Great contracts.ruby tutorial</a></li>
</ul>


<h2>Thanks!</h2>

<p>If you have any questions, suggestions or just want to chat about how contracts.ruby is awesome, you can ping me on twitter <a href="https://twitter.com/waterlink000">@waterlink000</a>. If you have any issues using <a href="https://github.com/egonSchiele/contracts.ruby">contracts.ruby</a> or <a href="https://github.com/waterlink/contracts-rspec">contracts-rspec</a> you can create issues on corresponding github project. Pull requests are welcome!</p>
]]></content>
  </entry>
  
</feed>
