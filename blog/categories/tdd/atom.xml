<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Tdd | Oleksii Fedorov's (waterlink) tech blog]]></title>
  <link href="http://waterlink.github.io/blog/categories/tdd/atom.xml" rel="self"/>
  <link href="http://waterlink.github.io/"/>
  <updated>2016-02-02T08:22:12+01:00</updated>
  <id>http://waterlink.github.io/</id>
  <author>
    <name><![CDATA[Oleksii Fedorov (waterlink)]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Test-Driven-Development Screencast #1]]></title>
    <link href="http://waterlink.github.io/blog/2016/02/02/test-driven-development-screencast-number-1/"/>
    <updated>2016-02-02T07:59:25+01:00</updated>
    <id>http://waterlink.github.io/blog/2016/02/02/test-driven-development-screencast-number-1</id>
    <content type="html"><![CDATA[<iframe width="560" height="315" src="https://www.youtube.com/embed/QnEvjrszst4?list=PLbNxoJawcer22UE8lT93-fX8ZYFNtoXFu" frameborder="0" allowfullscreen></iframe>


<p>Recommended to watch in a full-screen and on 720p or higher quality.</p>

<h2>Script</h2>

<p>Hello! I am Oleksii Fedorov, and this is the first episode of
Test-Driven-Development Screencast.</p>

<p>Today, I am going to briefly address following questions about
Test-Driven-Development:
- What TDD is?
- What are main benefits of doing TDD?</p>

<p>At the end I am going to demonstrate a small example on how to implement simple
sorting algorithm using TDD.</p>

<p>Let me open my slides. Don&rsquo;t worry: there are only three small slides.</p>

<pre><code>vim ./slides/*
</code></pre>

<p>TDD is Software Development discipline. Therefore, basic rules, defined by TDD,
are arbitrary, weird and are to be followed to the letter, if you want it to be
useful. There is a reason for that – but we will talk shortly about that. Let
me read these basic rules for you:</p>

<ol>
<li><p>You are not allowed to write a line of production code, unless test fails.</p>

<p>Which means, that I will have to write the test even before I have something
to test. It may sound stupid. Maybe, it is stupid. Maybe, it is not.</p>

<p>But the next rule is even more weird than the first one:</p></li>
<li><p>You are not allowed to write more of a test, that is sufficient to fail.</p>

<p>It is important to clarify, what ˝fail˝ means in this context. It means test
expectation failure, and compilation/parsing/interpretation failure
(depending if your programming language is compiled or interpreted).</p>

<p>Which means, that you will have to interrupt yourself, while writing a test,
because you have mentioned the class or package, that does not exist yet. Or
you have mentioned the method or function, that does not exist yet.</p>

<p>Now that may sound really stupid to you. Bear with me, and lets see how
weird the last rule is:</p></li>
<li><p>You are not allowed to write more production code, that is sufficient to
make the failing test pass.</p>

<p>Which means, that once you have defined a class, that was mentioned - you
have just fixed a failing test, and you have to go back and write more of
the test, or add new test.</p>

<p>Which means, that once you have defined a method, that was mentioned - you
have just fixed a failing test, and you have to got back and write more of
the test again.</p>

<p>Which means, that once you changed your production code only slightly in
direction of the correct implementation, you have to go back and write more
tests.</p>

<p>This is interesting. Now you got yourself in a very tight lock. In a very
tight feedback loop. Write a line of test, write a line of code, write a
line of test, write a line of code, and so on. The length of this loop is
probably 5, 10, 30 seconds. If you have a test suite that needs half an hour
to run, you will not do TDD.</p></li>
</ol>


<p>What happens if you do not follow this discipline to the letter? If you slip
there and there?: write a bit more production code, than you had to?, write a
bit more of a test, than you had to?, or even wrote a test after writing the
whole class under test?</p>

<p>Well, you have just lost the main benefit of TDD: you can no longer trust the
test suite. For sure, there will be some untested code if you do it this way.</p>

<p>Why do we need 100% test coverage, you ask? 70% sounds like an awesome
achievement! Or is it?..</p>

<p>What can you tell from the fact, that only 70% of your code is covered by test
suite? Only that 30% is not covered, and therefore, there is no quick and easy
way to verify that it works.</p>

<p>Lets imagine the following scenario:</p>

<ul>
<li>You open a file on your screen.</li>
<li>You spot some nasty duplication, and you know you want to fix it.</li>
<li>You even see an obvious way to fix it.</li>
<li>You touch your keyboard.</li>
<li>And now, the fear overwhelms you: this class is not tested.</li>
<li>And your reaction? - I won&rsquo;t touch it!</li>
</ul>


<p>That is where code starts to rot, while nobody cleans it up, because test suite
can not be trusted, and the whole codebase slowly down-slides to a big pile of
mess.</p>

<p>Now, lets imagine, that you have 100% code coverage (Well, maybe 98%, because
100% is the goal, that is not achievable). And the same scenario:</p>

<ul>
<li>You open a file on your screen.</li>
<li>You spot some nasty duplication.</li>
<li>You fix the duplication.</li>
<li>You run tests - and they are green.</li>
<li>You check-in cleaner code in your code control system.</li>
</ul>


<p>Or, lets say, that the problem is not trivial:
- You spot the long method.
- You split it in 3 methods - tests are still green.
- You proceed and extract these methods to the new class.
- And tests fail.
- Undo-Undo-Undo. And you are back to the green state.
- And now you think for a moment, what happened there.
- And you already have this ˝Gotcha!˝.
- And you successfully extract a class again - and the test suite is green.
- You check-in cleaner code in your code control system.</p>

<p>Undo button becomes your best friend. Once you stop knowing what is going on,
or what you are doing, or you simply confused, you can always go back to the
green state; that just happens to be 25 seconds ago (or 2-3 undo) away, because
of the tight feedback loop you got yourself into.</p>

<p>Now, there is a hidden rule of TDD. That feels more, like an implementation
detail of TDD:</p>

<pre><code>:next
</code></pre>

<p>As tests become more specific, production code should become more generic.</p>

<p>And it is very true, otherwise, you would end up adding a bunch of <code>if</code>
statements every time you add a failing test.</p>

<p>What that means, I will point out during the example.</p>

<p>And lets sum up now:</p>

<p>100% Code Coverage =>
  Lack of Fear =>
  Consistent Random Kindness to the Code =>
  Clean Code.</p>

<hr />

<p>60% Code Coverage =>
  Fear to Break It =>
  ˝I won&rsquo;t touch it!˝ =>
  Mess.</p>

<p>Now we can finally move on to the example. Next time, on the next episode of
Test-Driven-Development Screencast!</p>

<p>List of all TDD Screencasts can be <a href="/blog/categories/tdd-screencasts/">found here</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Object Oriented Design. Important Things]]></title>
    <link href="http://waterlink.github.io/blog/2015/03/12/object-oriented-design-important-things/"/>
    <updated>2015-03-12T23:23:45+01:00</updated>
    <id>http://waterlink.github.io/blog/2015/03/12/object-oriented-design-important-things</id>
    <content type="html"><![CDATA[<h2>Slides from my talk <a href="https://twitter.com/BrainlyGroup">@brainly</a> 12 Mar 2015</h2>

<p><em>Disclaimer: This is my personal vision, based on my knowledge and experience. If you want to challenge it, ask questions, provide feedback and discuss, feel free to ping me on twitter: <a href="https://twitter.com/waterlink000">@waterlink000</a>, I would love to hear from you.</em></p>

<p>Code examples are in ruby/pseudo-code.</p>

<iframe src="//www.slideshare.net/slideshow/embed_code/45775223" width="476" height="400" frameborder="0" marginwidth="0" marginheight="0" scrolling="no"></iframe>


<h2>Object Oriented Programming</h2>

<p>Most notable features of OOP:</p>

<ul>
<li>Encapsulation - keep data together with behavior that needs that data, effectively hiding this data from everything else.</li>
<li>Inheritance - usually a subclassing, inheriting all behavior and data, in some language even all private details.</li>
<li>Polymorphism - ability to substitute instances of one class with instances of others.</li>
</ul>


<h3>How important these features are for OO design?</h3>

<p>Imagine, that given 100 points you want to distribute them between these 3 features, and each number will represent an importance of corresponding feature.</p>

<p>This would be my answer (and my personal opinion):</p>

<table>
<thead>
<tr>
<th style="text-align:center;">Encapsulation</th>
<th style="text-align:center;">Polymorphism</th>
<th style="text-align:center;">Inheritance</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center;">80</td>
<td style="text-align:center;">40</td>
<td style="text-align:center;">-20</td>
</tr>
</tbody>
</table>


<p>And 100 = 80 + 40 + (-20) :)</p>

<h3>Why inheritance is so bad?</h3>

<p>Because it increases coupling (usually): subclass (usually) depends on some data and/or behavior of its superclass. Even worse: (usually) it is not public data/behavior. I.e.: it violates principle of encapsulation badly. (Usually).</p>

<p>There are actually cases, when you do want your classes to be in inheritance hierarchy, it is the case, when your domain has the same hierarchy naturally in real world. And type inheritance doesn&rsquo;t really mean behavior inheritance.</p>

<h3>So how to avoid violation of encapsulation using inheritance?</h3>

<ul>
<li>Be careful, use only public interfaces of your superclass.</li>
<li>Replace inheritance with composition and delegation, because when you use only public interfaces of superclass, then you don&rsquo;t really need inheritance.</li>
</ul>


<h2>Coupling</h2>

<h3>Why coupling is bad?</h3>

<p>Imagine you need to change behavior of class X.</p>

<p>You will have to change any other piece of code base, that directly depends on this behavior of class X.</p>

<p>More coupling you have, more changes will have to take place, and probably, in totally unrelated parts of codebase.</p>

<p>As a result it:</p>

<ul>
<li>Exponentially increases time required for change</li>
<li>Invites bugs (lots of)</li>
</ul>


<h3>Dependency</h3>

<p>Dependency, is basically what coupling is, - is not really your friend, so you need to watch out for them.</p>

<h3>How to deal with dependencies?</h3>

<ul>
<li>Dependency inversion principle - Instead of referring foreign system/package/class/module/whatever, refer an abstract interface.</li>
<li>Dependency injection - Technique, that allows to provision all dependencies to parts of your system and basically fulfill all required interfaces.</li>
</ul>


<h3>An example</h3>

<pre><code class="ruby">class Answer
  def rating
    RatingService.new.rating_for(comments, upvotes, downvotes)
  end
end
</code></pre>

<p>What is the problem with this code? - It is a dependency <code>Answer -&gt; RatingService</code>. What if you wanted to A/B test different rating models? You will definitely have troubles with that approach, especially if it is not the only place, that reference <code>RatingService</code>.</p>

<h3>Use dependency injection!</h3>

<pre><code class="ruby">class Answer
  def initialize(rating_service)
    @rating_service = rating_service
  end

  def rating
    @rating_service.rating_for(comments, upvotes, downvotes)
  end
end
</code></pre>

<p>Now you can easily have multiple rating services and A/B test them, or do whatever you want, it is really flexible.</p>

<h3>It is still coupling</h3>

<p>But coupling to abstract interface, instead of real implementation, which means, you can exchange different implementations without changing users of this interface. Which basically improves polymorphism features of your code. It is very loose coupling.</p>

<h2>Test Driven Development</h2>

<h3>How is it related to OO design?</h3>

<p>It provides very short feedback on your OO design:</p>

<ul>
<li>If you have troubles writing test - your design is wrong and you need to step back</li>
<li>If you don&rsquo;t like how your test look like - your design is wrong and you need to step back</li>
<li>If you have troubles making test green - your design is wrong and you need to step back</li>
</ul>


<p>It is really almost like pairing partner if used right! Of course pairing still provides even better feedback loop - real-time continuous feedback loop!</p>

<h3>Unit tests vs integration tests</h3>

<p>Integration tests are scam!:</p>

<ul>
<li>Very slow => bad feedback loop</li>
<li>Exponential count of paths to test</li>
</ul>


<h3>Unit tests just don&rsquo;t work. Are they?</h3>

<p>Everything works in isolation != the whole system works as expected.</p>

<p>Testing in isolation = providing fake objects and/or mocks for all your dependencies</p>

<p>Mocks and fake objects can make your unit test green, but in fact the code is broken, because one of the dependencies has changed its behavior or even public interface in unexpected fashion.</p>

<h3>Answer: Cut your system at value boundaries!</h3>

<p>Instead of method call boundaries. And we arrive at Actor Model.</p>

<h2>Actor Model</h2>

<p>Given this example:</p>

<pre><code class="ruby">class RatingService
  def rating_for(comments, upvotes, downvotes)
    # .. calculate rating somehow ..
  end
end
</code></pre>

<p>Problems with this class:</p>

<ul>
<li>Any user of this class will have to stub out its <code>#rating_for</code> in unit tests.</li>
<li>It invites additional behavior to be added (since it is as simple as adding additional public method), which will kill single responsibility feature of this class.</li>
</ul>


<h3>Actor Model solves this</h3>

<p>Warning, it is ruby pseudo-code:</p>

<pre><code class="ruby">actor RatingService
  comments, upvotes, downvotes, outbox = inbox.fetch
  # .. calculate rating somehow ..
  outbox.send(rating)
end

rating_service = RatingService.new
rating_service.start
</code></pre>

<h3>Way better now:</h3>

<ul>
<li>Allows unit testing easily without mocks and fake objects: by peeking inside its inbox in unit tests instead, and checking that it received right message.</li>
<li>It is really hard to pack more responsibility to this, since it has no methods, it has just one body, that is responsible for processing exactly one message.</li>
</ul>


<p><em>You of course can encode something strange in message, and organize your own method dispatch mechanism through actors inbox, but that is just silly (usually).</em></p>

<h3>Easy to unit test:</h3>

<pre><code class="ruby"># creating actor, but not starting it
rating_actor = RatingCalculator.new

# dependency injection of rating actor
answer_actor = Answer.new(answer_id, rating_actor)
answer_actor.start

render_actor = Render.new(answer_actor)
render_actor.run
expect(rating_actor.inbox)
  .to include([comments, upvotes, downvotes, outbox])

# fake response from rating actor
outbox.send(3.5)
expect(render_actor).to render_rating(3.5)
</code></pre>

<p>In unit tests you start only one actor - actor under test, and all other actors just get instantiated correctly and passed in as a dependencies where needed. Since they are not started, they will not consume any messages from their inbox, which means that you can consume these inboxes from your unit test, and check that the messages that arrived at inboxes are expected.</p>

<h2>When the code is done</h2>

<ul>
<li>It works!</li>
<li>It is readable (future me will not curse me for writing this code)</li>
<li>It has no duplication</li>
<li>And it is as short as possible (while maintaining all of the above)</li>
</ul>


<h3>Code comments</h3>

<p>Basically a code smell (I&rsquo;m not talking about documentation comments)</p>

<p>Example:</p>

<pre><code class="ruby"># when user is active
if activity_service.has_events(user.id, min_date: 2.weeks.ago)
  &amp;&amp; !user.fraud?
</code></pre>

<p>Which is bad from more than one point of view, it literally should have been:</p>

<pre><code class="ruby">if user.active?
# or
if activity_service.user_is_active?(user)
# .. more variations can be here ..
# .. but all of them will be better ..
</code></pre>

<h3>If code needs comment:</h3>

<ul>
<li>it is not readable</li>
<li>it fails to communicate its intent</li>
</ul>


<p>You should be able to read the code and understand it. In that order: read -> understand.</p>

<p>You shouldn&rsquo;t interpret it in your head. You shouldn&rsquo;t have Ruby (or your favorite language here) instance running in your head.</p>

<h2>To sum it up</h2>

<ul>
<li>Inheritance is good only in very rare cases</li>
<li>Coupling and dependencies are not your friends, take them under control with dependency inversion &amp; injection</li>
<li>TDD as a shortest feedback cycle for your OO design</li>
<li>Write code in such way, that you would thank yourself for that in the future</li>
</ul>


<p>Recommended reading: &ldquo;Pragmatic Programmer: From Journeyman to Master&rdquo; by Andrew Hunt and David Thomas. It is insanely good, concise book with lots of awesome references to other resources.</p>

<h2>Thanks!</h2>

<p>If you have any questions or suggestions, you can always reach me out on twitter <a href="https://twitter.com/waterlink000">@waterlink000</a>.</p>
]]></content>
  </entry>
  
</feed>
