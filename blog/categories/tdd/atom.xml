<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Tdd | That TDD Fellow | Tech Blog | Screencasts]]></title>
  <link href="http://www.tddfellow.com/blog/categories/tdd/atom.xml" rel="self"/>
  <link href="http://www.tddfellow.com/"/>
  <updated>2016-06-28T01:36:47+02:00</updated>
  <id>http://www.tddfellow.com/</id>
  <author>
    <name><![CDATA[Oleksii Fedorov (waterlink)]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[TDD #5: English Numbers Kata]]></title>
    <link href="http://www.tddfellow.com/blog/2016/06/19/tdd-number-5-english-numbers-kata/"/>
    <updated>2016-06-19T18:41:39+02:00</updated>
    <id>http://www.tddfellow.com/blog/2016/06/19/tdd-number-5-english-numbers-kata</id>
    <content type="html"><![CDATA[<iframe src="https://player.vimeo.com/video/171307899?color=c9ff23" width="640" height="360" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen></iframe>


<p><a href="https://vimeo.com/171307899">Test-Driven Development Screencast #5: English Numbers Kata</a></p>

<p><em>(Recommended to watch full-screen and HD: 720p or more)</em></p>

<p>List of all TDD Screencasts can be <a href="/blog/categories/tdd-screencasts/">found here</a>.</p>

<p>This screencast was born from my previous blog post: <a href="/blog/2016/05/27/iterative-divide-and-conquer-or-how-to-solve-problems/">Iterative Divide &amp; Conquer or How to solve problems</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[TDD as an Enabling Practice or How to Be Faster With TDD]]></title>
    <link href="http://www.tddfellow.com/blog/2016/06/13/tdd-as-an-enabling-practice-or-how-to-be-faster-with-tdd/"/>
    <updated>2016-06-13T07:52:56+02:00</updated>
    <id>http://www.tddfellow.com/blog/2016/06/13/tdd-as-an-enabling-practice-or-how-to-be-faster-with-tdd</id>
    <content type="html"><![CDATA[<p>Recently I had a lot of conversations with so many different programmers, with different backgrounds, contexts of work and opinions. What stroke me the most, is that majority feel that TDD is slower than simple automated testing, i.e., <code>TestFirst</code> is slower than <code>TestAfter</code>.</p>

<p>While digging deeper in their context of work, I could only agree with them: &ldquo;True, in that context it will be about 50% slower&rdquo;.</p>

<p>Most of the time, though, the context is somewhat looking like this:</p>

<ul>
<li>We have some company <code>ACME</code>, that does some sort of Agile Software Development (probably Scrum);</li>
<li>The company <code>ACME</code> focuses only on the business parts of Agile Software Development;</li>
<li>The company <code>ACME</code> tried to introduce TDD as a development practice;</li>
<li>Everything took much longer to be done.</li>
</ul>


<h2>Enabling practice</h2>

<p>Now, let us dive into the development practices of Agile Software Development: development practices are usually coming from Extreme Programming (XP). In XP there are 2 terms: <code>EnablingPractice</code> and <code>ExploitativePractice</code>.</p>

<p>Exploitative practice gives direct benefit to the team, e.g.: speed boost and quicker feedback from users and stakeholders.</p>

<p>Enabling practice is required for certain other exploitative practice(s) to work.</p>

<p>A good example of exploitative practice is Continuous Delivery. It requires Continuous Integration, Pair-Programming, and Testing to be in place. These 3 are enabling practices.</p>

<h2>Removing slow practices</h2>

<p>Additionally to allowing usage of practices, that make a team go faster and deliver at the higher quality level, enabling practices allow removal of practices, that make a team go slower. For example, Pair-Programming together with TDD allows removal of code review. On most of the teams (especially, of bigger size), this makes for an instant productivity boost.</p>

<p>Pair-Programming, TDD and Continuous Integration, additionally to enabling the team to do Continuous Delivery, also allows replacing feature-branch VCS flow with a trunk-based flow. This allows for smaller iterations and faster user feedback.</p>

<h2>Pair-Programming Done Right</h2>

<p>It is worth noting, that removal of code review and introducing of Continuous Delivery is only possible, if Pair-Programming is done right:</p>

<ul>
<li>in no case, two beginners should be working in the pair;</li>
<li>beginners should work together with advanced beginners/competents and proficients/experts;</li>
<li>advanced beginners/competents should split their time in half between working with beginners and working with proficient/experts.</li>
</ul>


<p>Terminology <code>Beginner</code>, <code>AdvancedBeginner</code>, <code>Competent</code>, <code>Proficient</code> and <code>Expert</code> is from Dreyfus Skill Acquisition Model.</p>

<p>That allows for a good trust and mentorship models in your team(s). It enables quick growth and knowledge sharing for every member of the team.</p>

<p>There is another enabling practice which speeds up the knowledge sharing, it is Pair Rotation, that should be done from 1 to 2 times per day, so that for small and middle-sized teams, the bigger the feature is, the higher chance, that everyone on the team have participated in its development, and therefore have enough knowledge about it.</p>

<p>Additionally, Pair Rotation allows for Code Detachment and removal of Code Silos. This in turn, together with TDD, enables Ruthless Refactoring, because you are not afraid:</p>

<ul>
<li>to break the code, thanks to TDD,</li>
<li>to upset an owner of the Code Silo, because there is no owner, thanks to Pair Rotation.</li>
</ul>


<h2>Bottomline</h2>

<p>I think I can go on like this forever, but I believe the idea should be clear. I will be following up with more articles in details on each technique in the future. Stay tuned!</p>

<h2>Thank you for reading!</h2>

<p>If you, my dear reader, have any thoughts, questions or arguments about the topic, feel free to reach out to me on twitter: <a href="https://twitter.com/waterlink000">@waterlink000</a>.</p>

<p>If you liked my ideas, follow me on twitter, and, even better, provide me with your honest feedback, so that I can improve.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[TDD #4: Path Finding]]></title>
    <link href="http://www.tddfellow.com/blog/2016/02/13/tdd-number-4-path-finding/"/>
    <updated>2016-02-13T09:56:15+01:00</updated>
    <id>http://www.tddfellow.com/blog/2016/02/13/tdd-number-4-path-finding</id>
    <content type="html"><![CDATA[<iframe width="560" height="315" src="https://www.youtube.com/embed/DTzhlNIjWRY" frameborder="0" allowfullscreen></iframe>


<p>Recommended to watch in a full-screen and on 720p or higher quality.</p>

<p>List of all TDD Screencasts can be <a href="/blog/categories/tdd-screencasts/">found here</a>.</p>

<h2>Script</h2>

<p>Hello. I am Oleksii Fedorov and I am wearing a hat of That TDD Fellow. That
means you are watching TDD Screencast episode #4.</p>

<p>As mentioned in the previous episode, today we are going to implement a path
finding algorithm.</p>

<p>Specifically, our first problem in a path finding theme will be the following:</p>

<ul>
<li>We are given a directional graph, that consists of nodes and edges between
them.</li>
<li>We are given two nodes: start and finish.</li>
<li>We need to answer such questions:

<ul>
<li>Is there a path from start to finish?</li>
<li>If there is, What this path is?</li>
</ul>
</li>
</ul>


<p>I need to make a remark, that we clearly dont have to return the shortest path,
just any path, that we can find. We will tackle shortest path problem in later
episodes.</p>

<p>Now, I think we can start.</p>

<pre><code>./watch.sh
vim         # coding session
</code></pre>

<p>This was pretty easy to make a DFS algorithm to emerge on its own, by driving
it with the specification. Lets see if it is possible to do the same with
shortest path problem.. Next time, on the TDD Screencast. Have a nice day.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[TDD #3: Kind Sort]]></title>
    <link href="http://www.tddfellow.com/blog/2016/02/04/tdd-number-3-kind-sort/"/>
    <updated>2016-02-04T01:16:18+01:00</updated>
    <id>http://www.tddfellow.com/blog/2016/02/04/tdd-number-3-kind-sort</id>
    <content type="html"><![CDATA[<iframe width="560" height="315" src="https://www.youtube.com/embed/TR2hKaR4zg8" frameborder="0" allowfullscreen></iframe>


<p>Recommended to watch in a full-screen and on 720p or higher quality.</p>

<h2>Script</h2>

<p>Hello, hello! I am Oleksii Fedorov, and this is the third
episode of TDD Screencast.</p>

<p>In last episode we have implemented a sorting algorithm
using TDD, without thinking about algorithm beforehand. As a
result, bubble sort have emerged.</p>

<p>We have noticed, that there is a small weird thing about
this implementation: it has unspecified behavior - mutation
of the original array.</p>

<p>So we asked, which algorithm would emerge, if we were to ban
such side-effects from our algorithm. Let&rsquo;s find out!</p>

<pre><code>./watch.sh
vim           # implement sorting algorithm
</code></pre>

<p>I think we are done here. If you look closely, it is a
quicksort. It is not the most memory-efficient
implementation, but that is something that is simple to
optimize (instead of passing recursively arrays, pass
original array and indexes). That optimization will involve
actual mutation of the array in place, so if we want to stay
true to our specification /show test for no-side-effects/.
We will have to copy the array once, using some sort of
wrapper function.</p>

<p>Applying this optimization I leave as an exercise to you my
users.</p>

<p>In the next episode we will look into path-finding problem,
and we will see, how these techniques apply there. See you
next time! Have a nice day.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Test-Driven-Development Screencast #2]]></title>
    <link href="http://www.tddfellow.com/blog/2016/02/02/test-driven-development-screencast-number-2/"/>
    <updated>2016-02-02T08:28:14+01:00</updated>
    <id>http://www.tddfellow.com/blog/2016/02/02/test-driven-development-screencast-number-2</id>
    <content type="html"><![CDATA[<iframe width="560" height="315" src="https://www.youtube.com/embed/6XMoZ7snuKo?list=PLbNxoJawcer22UE8lT93-fX8ZYFNtoXFu" frameborder="0" allowfullscreen></iframe>


<p>Recommended to watch in a full-screen and on 720p or higher quality.</p>

<p>List of all TDD Screencasts can be <a href="/blog/categories/tdd-screencasts/">found here</a>.</p>

<h2>Script</h2>

<p>Hello, hello! I am Oleksii Fedorov, and this is the second episode of
Test-Driven-Development Screencast.</p>

<p>Now that I think about it, first episode was more of an audio podcast (with two
and half visual slides), rather than a screencast. Don&rsquo;t worry - this episode
will be full of code and actual action time on the screen.</p>

<p>Today we are going to implement a sorting algorithm. We will not come up with
algorithm beforehand and we will simply let it emerge by itself, while we are
doing TDD.</p>

<p>Lets jump in!</p>

<pre><code>./watch.sh  # So I have here small script, that will watch changes in my code
            # and will run all my tests. Additionally, it will show me the
            # result in the notification bar (you will see, shortly).

vim         # 1) Create test file
            # 2) Follow TDD rules to the letter
</code></pre>

<p>I think we are done here. And notice, that this is a bubble sort algorithm. Now
lets ask a question, why the worst possible algorithm have emerged, while we
were using TDD. That is an interesting question.</p>

<p>But first, lets ask ourselves a question: Are we kind to the user of our
function? The answer is - NO. We are mutating the argument, that user passed to
us. And this mutation might be unexpected. At least our test suite doesn&rsquo;t even
mention such behavior.</p>

<p>The root of the problem is this little swap operation that we have here:</p>

<pre><code># show swap operation on the screen
a[0], a[1] = {a[1], a[0]}
</code></pre>

<p>I wonder, what will happen if we were to ban swap operation (and any kind of
mutation of the argument of the function), and implement sorting algorithm
again?</p>

<p>Find out next time, on the next episode of Test-Driven-Development! Have a good
day.</p>
]]></content>
  </entry>
  
</feed>
